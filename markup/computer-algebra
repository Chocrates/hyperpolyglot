//a side-by-side reference sheet//

[#grammar-invocation grammar and invocation] | [#var-expr variables and expressions] | [#arithmetic-logic arithmetic and logic] | [#strings strings] | [#resizable-arrays resizable arrays] | [#arith-seq arithmetic sequences] | [#dictionaries dictionaries] | [#functions functions] | [#execution-control execution control] | [#exceptions exceptions] | [#streams streams] | [#files files] | [#directories directories] | [#libraries-namespaces libraries and namespaces] |  [#reflection reflection]
 
[#vectors vectors] | [#matrices matrices] | [#symbolic-expr symbolic expressions] | [#calculus calculus] | [#equations-unknowns equations and unknowns] | [#optimization optimization] | [#combinatorics combinatorics] | [#number-theory number theory] | [#elliptic-curves elliptic curves] | [#rational-algebraic-numbers rational and algebraic numbers] | [#polynomials polynomials] | [#trigonometry trigonometry] | [#special-functions special functions] | [#permutations permutations] | [#groups groups] | [#subgroups subgroups] | [#group-homomorphisms group homomorphisms] | [#actions actions] | [#descriptive-statistics descriptive statistics] | [#distributions distributions] 

[#univariate-charts univariate charts] | [#bivariate-charts bivariate charts] | [#trivariate-charts trivariate charts]

||~ ||~ [#mathematica mathematica]||~ [#sympy sympy]||~ [#gap gap]||~ [#pari-gp pari/gp]||
||[[# version-used]][#version-used-note version used] _
@<&nbsp;>@||##gray|//10.0//##||##gray|//Python 2.7; SymPy 0.7//##||##gray|//4.7//##||##gray|//2.7//##||
||[[# show-version]][#show-version-note show version] _
@<&nbsp;>@||##gray|//select// About Mathematica //in// Mathematica //menu//##||@@sympy.__version__@@||$ gap -h||$ gp @@--@@version||
||[[# implicit-prologue]][#implicit-prologue-note implicit prologue]|| ||import sympy _
 _
##gray|# enable LaTeX rendering in Jupyter notebook:## _
sympy.init_printing()|| || ||
||||||||||~ [[# grammar-invocation]][#grammar-invocation-note grammar and invocation]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# interpreter]][#interpreter-note interpreter] _
@<&nbsp;>@||$ cat @@>>@@ hello.m _
Print["Hello, World!"] _
 _
$  MathKernel -script hello.m||##gray|//if// foo.py //imports sympy://## _
$ python ##gray|//foo//##.py|| ||$ cat hello.gp _
print("Hello, World!") _
quit _
 _
$ gp -q hello.gp _
Hello, World!||
||[[# repl]][#repl-note repl] _
@<&nbsp;>@||$ MathKernel||$ python _
@@>>>@@ import sympy||$ gap||$ gp||
||[[# block-delimiters]][#block-delimiters-note block delimiters] _
@<&nbsp;>@||( ##gray|//stmt//##; ##gray|//...//##)||: ##gray|//and offside rule//##||function( ) ##gray|//...//## end _
if then ##gray|//...//## elif then ##gray|//...//##  else ##gray|//...//## fi _
while do ##gray|//...//## od _
for do ##gray|//...//## od||{ ##gray|//...//## } _
 _
##gray|//braces cannot be nested//##||
||[[# stmt-separator]][#stmt-separator-note statement separator]||; ##gray|//or sometimes newline//## _
 _
##gray|//A semicolon suppresses echoing value of previous expression.//##||##gray|//newline or//## ; _
 _
##gray|//newlines not separators inside (), [], {}, triple quote literals, or after backslash: @@\@@//##||; _
 _
##gray|//Two trailing semicolons// ;;  //suppress echoing value of previous expression.//##||##gray|//newline or//## ; _
 _
##gray|//Newlines don't separate statements inside braces.//## _
 _
##gray|//A semicolon suppresses echoing value of previous expression.//##||
||[[# eol-comment]][#eol-comment-note end-of-line comment] _
@<&nbsp;>@||##gray|//none//##||1 + 1 ##gray|# addition##||1 + 1; ##gray|# addition##||1 + 1 ##gray|\\ addition##||
||[[# multiple-line-comment]][#multiple-line-comment-note multiple line comment] _
@<&nbsp;>@||1 + ##gray|(* addition *)## 1||##gray|//none//##||##gray|//none//##||1 + ##gray|/* addition */## 1||
||||||||||~ [[# var-expr]][#var-expr-note variables and expressions]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# assignment]][#assignment-note assignment]||a = 3 _
Set[a, 3] _
 _
##gray|(* rhs evaluated each time a is accessed: *)## _
a := x + 3 _
SetDelayed[a, x + 3]||a = 3||a := 3;||x = 3.14||
||[[# parallel-assignment]][#parallel-assignment-note parallel assignment]||{a, b} = {3, 4} _
Set[{a, b}, {3, 4}]||a, b = 3, 4||##gray|//none//##||[a, b] = [3, 4]||
||[[# compound-assignment]][#compound-assignment-note compound assignment]||+= -= *= /= _
##gray|//corresponding functions://## _
AddTo SubtractFrom TimeBy DivideBy||+= -= *= /= @@//=@@ %= @@**=@@||##gray|//none//##||+= -= *= /= \= \/= %= _
 _
##gray|@@\\@@ bit operations:## _
@@<<= >>=@@||
||[[# incr-decr]][#incr-decr-note increment and decrement]||++x @@--@@x _
PreIncrement[x] PreDecrement[x] _
x++ x@@--@@ _
Increment[x] Decrement[x]||##gray|//none//##||##gray|//none//##||##gray|//postmodifiers://## _
x++ x@@--@@||
||[[# non-referential-id]][#non-referential-id-note non-referential identifier]||##gray|//any unassigned identifier is non-referential//##||x, y, z, w = sympy.symbols('x y z w')||##gray|//none//##||##gray|//any unassigned identifier is non-referential//##||
||[[# id-as-val]][#id-as-val-note identifier as value]||x = 3 _
y = HoldForm[x]|| || ||x = 3 _
y = 'x||
||[[# global-var]][#global-var-note global variable]||##gray|//variables are global by default//##||g1, g2 = 7, 8 _
 _
def swap_globals(): _
@<&nbsp;&nbsp;>@global g1, g2 _
@<&nbsp;&nbsp;>@g1, g2 = g2, g1|| ||##gray|//variables are global by default//##||
||[[# local-var]][#local-var-note local variable]||Module[{x = 3, y = 4}, Print[x + y]] _
 _
##gray|(* makes x and y read-only: *)## _
With[{x = 3, y = 4}, Print[x + y]] _
 _
##gray|(* Block[ ] declares dynamic scope *)##||##gray|//assignments inside functions are to local variables by default//##|| ||tmp = 19 _
 _
add(x, y, z) = { _
@<&nbsp;&nbsp;>@##gray|@@\\@@ don't overwrite global tmp:## _
@<&nbsp;&nbsp;>@my(tmp = x + y); _
@<&nbsp;&nbsp;>@tmp + z _
} _
 _
##gray|@@\\@@ local keyword declares dynamic scope##||
||[[# null]][#null-note null] _
@<&nbsp;>@||Null||None|| ||##gray|//none//##||
||[[# null-test]][#null-test-note null test] _
@<&nbsp;>@||x == Null||x is None|| ||##gray|//none//##||
||[[# undef-var]][#undef-var-note undefined variable access] _
@<&nbsp;>@||##gray|//treated as an unknown number//##||##gray|//raises// NameError##||##gray|//error//##||##gray|//treated as an unknown number//##||
||[[# rm-var-binding]][#rm-var-binding-note remove variable binding]||Clear[x] _
Remove[x]||del x|| ||kill(x)||
||[[# cond-expr]][#cond-expr-note conditional expression] _
@<&nbsp;>@||If[x > 0, x, -x]||x if x > 0 else -x|| ||if(x > 0, x, -x)||
||||||||||~ [[# arithmetic-logic]][#arithmetic-logic-note arithmetic and logic]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# true-false]][#true-false-note true and false] _
@<&nbsp;>@||True False||True False||true false||1 0||
||[[# falsehoods]][#falsehoods-note falsehoods] _
@<&nbsp;>@||False||False 0 0.0||false||0 _
0.0 _
Mod(0, 5) _
Pol([0]) _
[0, 0, 0] _
[0, 0; 0, 0] _
[[0, 0], 0]||
||[[# logical-op]][#logical-op-note logical operators]||! True @@||@@ (True && False) _
Or[Not[True], And[True, False]]||sympy.Or(sympy.Not(True), sympy.And(True, False)) _
 _
##gray|# when arguments are symbols:## _
@@~ x | (y & z)@@||not true or (true and false)||@@&& || !@@||
||[[# relational-op]][#relational-op-note relational operators]||== != > < >= <= _
##gray|//corresponding functions://## _
Equal Unequal Greater Less GreaterEqual LessEqual||sympy.Eq sympy.Ne sympy.Gt sympy.Lt sympy.Ge sympy.Le _
 _
##gray|# when arguments are symbols:## _
== != > < >= <=||@@=@@ <> < > <= >=||== != > < >= <=||
||[[# arith-op]][#arith-op-note arithmetic operators]||+ - * / Quotient Mod _
##gray|//adjacent terms are multiplied, so * is not necessary.// Quotient //and// Mod //are functions, not binary infix operators.  These functions are also available://## _
Plus Subtract Times Divide||+ - * / ##gray|//??//## % _
 _
##gray|//if an expression contains a symbol, then the above operators are rewritten using the following classes://## _
sympy.Add sympy.Mul sympy.Pow sympy.Mod||+ - * / mod _
 _
##gray|//the operators// + - * / //are overloaded for integers, rationals, and floats; other arithmetic functions aren't and there are no implicit conversions; use constructors to convert://## _
Rat(3.1) _
Float(3) _
Float(31/10)||+ - * / %||
||[[# int-div]][#int-div-note integer division] _
@<&nbsp;>@||Quotient[a, b]|| ||QuoInt(a, b);||a \ b _
divrem(a, b)[1] _
 _
##gray|@@\\@@ rounded integer division:## _
a \/ b||
||[[# int-div-zero]][#int-div-zero-note integer division by zero]||##gray|//dividend is zero://## _
Indeterminate _
##gray|//otherwise://## _
ComplexInfinity|| ||##gray|//error//##||##gray|//error//##||
||[[# float-div]][#float-div-note float division]||##gray|//exact division://## _
a / b|| ||##gray|//depending upon the types of a and b, the value can be an exact rational, a machine float, or an arbitrary precision float://## _
a / b||7 / 3||
||[[# float-div-zero]][#float-div-zero-note float division by zero]||##gray|//dividend is zero://## _
Indeterminate _
##gray|//otherwise://## _
ComplexInfinity|| ||##gray|//error//##||##gray|//error//##||
||[[# power]][#power-note power]||2 ^ 32 _
Power[2, 32]||2 ** 32 _
sympy.Pow(2, 32)||2 ^ 32||2 ^ 32||
||[[# sqrt]][#sqrt-note sqrt]||##gray|//returns symbolic expression://## _
Sqrt[2]||sympy.sqrt(2)||2.0 ^ 0.5||sqrt(2)||
||[[# sqrt-negative-one]][#sqrt-negative-one-note sqrt -1] _
@<&nbsp;>@||I||sympy.I||##gray|-1.0 ^ 0.5 //evaluates to// -1.##||1.000 * I||
||[[# transcendental-func]][#transcendental-func-note transcendental functions]||Exp Log _
Sin Cos Tan _
ArcSin ArcCos ArcTan _
ArcTan _
##gray|ArcTan //accepts 1 or 2 arguments//##||symp.exp sympy.log _
sympy.sin sympy.cos sympy.tan _
sympy.asin sympy.acos sympy.atan _
sympy.atan2||##gray|//arguments must be floats; no implicit conversion of integers to floats://## _
Exp Log _
Sin Cos Tan _
Asin Acos Atan _
Atan2(##gray|//y//##, ##gray|//x//##)||exp log ##gray|//none//## _
sin cos tan _
asin acos atan _
##gray|//none//##||
||[[# transcendental-const]][#transcendental-const-note transcendental constants] _
##gray|//π and Euler's number//##||Pi E||sympy.pi sympy.E||FLOAT.PI FLOAT.E||Pi exp(1)||
||[[# float-truncation]][#float-truncation-note float truncation] _
##gray|//round towards zero, round to nearest integer, round down, round up//##||IntegerPart Round Floor Ceiling||sympy.floor _
sympy.ceiling||Trunc Round Floor Ceil||truncate(x) _
round(x) _
floor(x) _
ceil(x)||
||[[# absolute-val]][#absolute-val-note absolute value] _
##gray|//and signum//##||Abs Sign||sympy.Abs sympy.sign||AbsInt _
##gray|//no absolute value for floats?//## _
SignInt _
SignFloat||abs(x) _
sign(x)||
||[[# int-overflow]][#int-overflow-note integer overflow] _
@<&nbsp;>@||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||
||[[# float-overflow]][#float-overflow-note float overflow] _
@<&nbsp;>@||##gray|//none//##|| ||##gray|# prints as inf:## _
FLOAT.INFINTY||##gray|//error//##||
||[[# rational-construction]][#rational-construction-note rational construction]||2 / 7||sympy.Mul(2, sympy.Pow(7, -1))||2 / 7||2 / 7||
||[[# rational-decomposition]][#rational-decomposition-note rational decomposition] _
@<&nbsp;>@||Numerator[x/y] _
Denominator[x/y]||numer, denom = sympy.fraction(x, y)||x := 2 / 7; _
NumeratorRat(x); _
DenominatorRat(x);||x = 2 / 7 _
numerator(x) _
denominator(x)||
||[[# decimal-approx]][#decimal-approx-note decimal approximation]||N[2 / 7] _
2 / 7 + 0. _
2 / 7 @@//@@ N _
N[2 / 7, 100]||sympy.N(sympy.Rational(2, 7)) _
sympy.N(sympy.Rational(2, 7), 100)|| ||2 / 7 + 0. _
 _
##gray|@@\\@@ change precision to 100:## _
\p 100 _
2 / 7 + 0.||
||[[# complex-construction]][#complex-construction-note complex construction] _
@<&nbsp;>@||1 + 3I||1 + 3 * sympy.I||##gray|//none//##||1 + 3 * I||
||[[# complex-decomposition]][#complex-decomposition-note complex decomposition] _
##gray|//real and imaginary part, argument and modulus, conjugate//##||Re Im _
Arg Abs _
Conjugate||sympy.re sympy.im _
sympy.Abs sympy.arg _
sympy.conjugate||##gray|//none//##||real(z) imag(z) _
arg(z) abs(z) _
conj(z)||
||[[# random-num]][#random-num-note random number] _
##gray|//uniform integer, uniform float//##||RandomInteger[{0, 99}] _
RandomReal[]|| ||rs := RandomSource(IsMersenneTwister); _
Random(rs, 0, 99); _
##gray|//??//##||random(100) _
random(1.0)||
||[[# random-seed]][#random-seed-note random seed] _
##gray|//set, get//##||SeedRandom[17] _
##gray|//??//##|| ||rs := RandomSource(IsMersenneTwister, 17); _
State(rs);||setrand(17) _
getrand()||
||[[# bit-op]][#bit-op-note bit operators]||BitAnd[5, 1] _
BitOr[5, 1] _
BitXor[5, 1] _
BitNot[5] _
BitShiftLeft[5, 1] _
BitShiftRight[5, 1]|| ||##gray|//none//##||##gray|@@\\@@ left shift:## _
5 @@<<@@ 1 _
##gray|@@\\@@ right shift:## _
5 @@>>@@ 1||
||[[# binary-octal-hex-literals]][#binary-octal-hex-literals-note binary, octal, and hex literals]||2@@^^@@101010 _
8@@^^@@52 _
16@@^^@@2a|| ||##gray|//none//##|| ||
||[[# radix]][#radix-note radix]||BaseForm[42, 7] _
BaseForm[7^^60, 10]|| ||##gray|//none//##||##gray|@@\\@@ 42 as powers of 7 up to 9th power:## _
42 + O(7^10)||
||[[# to-array-of-digits]][#to-array-of-digits-note to array of digits]||##gray|(* base 10: *)## _
IntegerDigits[1234] _
##gray|(* base 2: *)## _
IntegerDigits[1234, 2]|| ||ListOfDigits(1234); _
 _
##gray|# other bases?##||##gray|@@\\@@ base 10:## _
digits(1234) _
##gray|@@\\@@ base 2:## _
digits(1234, 2) _
##gray|@@\\@@ number of digits in base 10:## _
sizedigits(1234)||
||||||||||~ [[# strings]][#strings-note strings]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# str-literal]][#str-literal-note string literal] _
@<&nbsp;>@||"don't say \"no\""||##gray|//use//## [[[scripting#strings|Python strings]]]||"don't say \"no\""||"don't say \"no\""||
||[[# newline-in-str-literal]][#newline-in-str-literal-note newline in literal] _
@<&nbsp;>@||##gray|//yes//##|| ||##gray|//no//##||##gray|//no; use \n escape//##||
||[[# str-literal-esc]][#str-literal-esc-note literal escapes]||\\ \" \b \f \n \r \t \##gray|//ooo//##|| ||\b \c \n \r \" \' \\ \##gray|//ooo//## _
 _
##gray|//when writing to a buffered output stream, encountering a// \c //causes a flush of output.//##||\n \t \" \\||
||[[# str-concat]][#str-concat-note concatenate] _
@<&nbsp;>@||"one " <> "two " <> "three"|| ||Concatenation("one ", "two ", "three");||Str("one ", "two ", "three") _
concat("one ", "two ", "three")||
||[[# translate-case]][#translate-case-note translate case]||ToUpperCase["foo"] _
ToLowerCase["FOO"]|| ||UppercaseString("foo"); _
LowercaseString("FOO");|| ||
||[[# trim]][#trim-note trim] _
@<&nbsp;>@||StringTrim[" foo "]|| ||##gray|//none//##|| ||
||[[# num-to-str]][#num-to-str-note number to string] _
@<&nbsp;>@||"value: " <> ToString[8]|| ||Concatenation("value: ", String(8));||Str(8) _
 _
##gray|@@\\@@ implicit conversion to string:## _
concat("value: ", 8)||
||[[# str-to-num]][#str-to-num-note string to number]||7 + ToExpression["12"] _
73.9 + ToExpression[".037"]|| ||7 + Int("12"); _
73.9 + Float(".037");||7 + eval("12") _
73.9 + eval(".037")||
||[[# str-join]][#str-join-note string join]||StringJoin[Riffle[{"foo", "bar", "baz"}, ","]]|| ||a := ["foo", "bar", "baz"]; _
JoinStringsWithSeparator(a, ","); || ||
||[[# split]][#split-note split] _
@<&nbsp;>@||StringSplit["foo,bar,baz", ","]|| ||SplitString("foo,bar,baz", ",");|| ||
||[[# str-subst]][#str-subst-note substitute]||s = "do re mi mi" _
re = RegularExpression["mi"] _
 _
##gray|(* replace first occurrence: *)## _
StringReplace[s, re -> "ma", 1] _
##gray|(* replace all occurrences: *)## _
StringReplace[s, re -> "ma"]|| ||##gray|# replace all occurrences:## _
ReplacedString("do re mi mi", "mi", "ma");|| ||
||[[# str-len]][#str-len-note length] _
@<&nbsp;>@||StringLength["hello"]|| ||Length("hello");||length("hello") _
#"hello"||
||[[# index-substr]][#index-substr-note index of substring]||StringPosition["hello", "el"][[1]][[1]] _
 _
##gray|(* The index of the first character is 1.*)## _
 _
##gray|(* StringPosition returns an array of pairs, one for each occurrence of the substring.  Each pair contains the index of the first and last character of the occurrence. *)##|| || || ||
||[[# extract-substr]][#extract-substr-note extract substring]||##gray|(* "el": *)## _
StringTake["hello", {2, 3}]|| ||s := "hello"; _
s{[2..3]};|| ||
||[[# char-literal]][#char-literal-note character literal] _
@<&nbsp;>@||##gray|//none//##|| ||'h'|| ||
||[[# lookup-char]][#lookup-char-note character lookup]||Characters["hello"][[1]]|| ||s := "hello"; _
##gray|# the character 'h':## _
s[1]; _
 _
##gray|# cannot use index notation on string literal##|| ||
||[[# chr-ord]][#chr-ord-note chr and ord]||FromCharacterCode[{65}] _
ToCharacterCode["A"][[1]]|| ||CharInt(65) _
IntChar('A')||Strchr([65]) _
Vecsmall("A")||
||[[# delete-char]][#delete-char-note delete characters]||rules = {"a" -> "", "e" -> "", "i" -> "", _
@<&nbsp;&nbsp;>@"o" -> "", "u" -> ""} _
StringReplace["disemvowel me", rules]|| ||s := "disemvowel me"; _
##gray|# no retval; modifies s in place:## _
RemoveCharacters(s, "aeiou"); || ||
||||||||||~ [[# resizable-arrays]][#resizable-arrays-note resizable arrays]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# array-literal]][#array-literal-note literal]||{1, 2, 3} _
 _
List[1, 2, 3]||##gray|//use//## [[[scripting#arrays|Python lists]]]||[1, 2, 3]; _
 _
##gray|# creates array with gap at fourth index; _
# reading a[4] causes an error:## _
a := [1, 2, 3, , 5];||##gray|\\ [1, 2, 3] is a vector literal:## _
List([1, 2, 3])||
||[[# array-size]][#array-size-note size] _
@<&nbsp;>@||Length[{1, 2, 3}]|| ||Length([1, 2, 3]);||length(List([1, 2, 3])) _
#List([1, 2, 3])||
||[[# array-lookup]][#array-lookup-note lookup]||##gray|(* access time is O(1) *)## _
##gray|(* indices start at one: *)## _
{1, 2, 3}[[1]] _
 _
Part[{1, 2, 3}, 1]|| ||##gray|# indices start at one:## _
a := [1, 2, 3]; _
a[1];||##gray|\\ access time is O(1).## _
##gray|\\ indices start at one:## _
List([1, 2, 3])[1]||
||[[# array-update]][#array-update-note update] _
@<&nbsp;>@||a[[1]] = 7|| ||a[1] := 7;||listput(a, 7, 1)||
||[[# array-out-of-bounds]][#array-out-of-bounds-note out-of-bounds behavior]||##gray|//left as unevaluated// Part[] //expression//##|| ||##gray|//Lookups result in errors; arrays can have gaps which also cause lookup errors. _
 _
An update will expand the array, possibly creating gaps.//##||##gray|//out of allowed range error//##||
||[[# array-element-index]][#array-element-index-note element index]||##gray|(* Position returns list of all positions: *)## _
First /@ Position[{7, 8, 9, 9}, 9]|| ||##gray|# returns 3:## _
Position([7, 8, 9, 9], 9); _
 _
##gray|# returns [3, 4]:## _
Positions([7, 8, 9, 9], 9);||##gray|//none//##||
||[[# array-slice]][#array-slice-note slice] _
@<&nbsp;>@||{1, 2, 3}[[1 ;; 2]]|| || ||##gray|//none//##||
||[[# array-of-integers-as-index]][#array-of-integers-as-index-note array of integers as index]||##gray|(* evaluates to {7, 9, 9} *)## _
{7, 8, 9}[[{1, 3, 3}]]|| || ||##gray|//none//##||
||[[# array-back]][#array-back-note manipulate back]||a = {6,7,8} _
AppendTo[a, 9] _
elem = a[[Length[a]]] _
a = Delete[a, Length[a]] _
elem|| ||a = [6, 7, 8]; _
Add(a, 9); _
elem := Remove(a);||a = List([6, 7, 8]) _
listput(a, 9) _
elem = listpop(a)||
||[[# array-front]][#array-front-note manipulate front]||a = {6,7,8} _
PrependTo[a, 5] _
elem = a[[1]] _
a = Delete[a, 1] _
elem|| || ||a = List([6, 7, 8]); _
listinsert(a, 5, 1); _
elem = a[1]; _
listpop(a, 1);||
||[[# array-head]][#array-head-note head] _
@<&nbsp;>@||First[{1, 2, 3}]|| || ||List([1, 2, 3])[1]||
||[[# array-tail]][#array-tail-note tail] _
@<&nbsp;>@||Rest[{1, 2, 3}]|| || ||##gray|//none//##||
||[[# array-cons]][#array-cons-note cons]||##gray|(* first arg must be an array *)## _
Prepend[{2, 3}, 1]|| || ||a = List([1, 2, 3]); _
listinsert(a, 1, 1);||
||[[# array-concatenate]][#array-concatenate-note concatenate] _
@<&nbsp;>@||Join[{1, 2, 3}, {4, 5, 6}]|| ||Concatenation([1, 2, 3], [4, 5, 6]);||concat(List([1, 2, 3]), List([4, 5, 6]))||
||[[# array-replicate]][#array-replicate-note replicate] _
@<&nbsp;>@||ten_zeros = Table[0, {i, 0, 9}]|| || || ||
||[[# copy-array]][#copy-array-note copy] _
@<&nbsp;>@||a2 = a|| || ||a2 = a||
||[[# iterate-over-array]][#iterate-over-array-note iterate] _
@<&nbsp;>@||Function[x, Print[x]] /@ {1, 2, 3}|| ||Perform([1, 2, 3], function(x) Print(x); Print("\n"); end);||a = List([1, 2, 3]) _
 _
for(i=1, length(a), print(a[i]))||
||[[# reverse-array]][#reverse-array-note reverse] _
@<&nbsp;>@||Reverse[{1, 2, 3}]|| ||Reversed([1, 2, 3])||a = List([1, 2, 3]) _
a2 = listcreate() _
while(i > 0, listput(a2, a[i]); i--)||
||[[# sort-array]][#sort-array-note sort]||Sort[{3, 1, 4, 2}]|| ||A := [3, 1, 4, 2] _
Sort(A);||a = List([3,1,4,2]) _
listsort(a) _
a||
||[[# dedupe-array]][#dedupe-array-note dedupe] _
@<&nbsp;>@||DeleteDuplicates[{1, 2, 2, 3}]|| ||Set([1, 2, 2, 3]); _
Unique([1, 2, 2, 3]);||Set([1, 2, 2, 3])||
||[[# membership]][#membership-note membership] _
@<&nbsp;>@||MemberQ[{1, 2, 3}, 2]|| ||2 in [1, 2, 3]||##gray|@@\\@@ returns 1-based index of first occurrence _
@@\\@@ or 0 if not found:## _
setsearch([1, 2, 3], 2)||
||[[# intersection]][#intersection-note intersection] _
@<&nbsp;>@||Intersect[{1, 2}, {2, 3, 4}]|| ||Intersection(Set([1, 2]), Set([2, 3, 4]));||setintersect([1, 2], [2, 3, 4])||
||[[# union]][#union-note union] _
@<&nbsp;>@||Union[{1, 2}, {2, 3, 4}]|| ||Union(Set([1, 2]), Set([2, 3, 4]));||setunion([1, 2], [2, 3, 4])||
||[[# set-diff]][#set-diff-note relative complement, symmetric difference]||Complement[{1, 2, 3}, {2}] _
##gray|//none//##|| || ||setminus([1, 2, 3], [2]) _
##gray|//??//##||
||[[# map]][#map-note map]||Map[Function[x, x x], {1, 2, 3}] _
 _
Function[x, x x] /@ {1, 2, 3} _
 _
##gray|(* if function has Listable attribute, Map is unnecessary: *)## _
sqr[x_] := x * x _
SetAttributes[sqr, Listable] _
sqr[{1, 2, 3, 4}]|| ||A := [1, 2, 3]; _
 _
##gray|# modifies A:## _
Apply(A, x -> x * x);||apply(x -> x * x, [1, 2, 3])||
||[[# filter]][#filter-note filter] _
@<&nbsp;>@||Select[{1, 2, 3}, # > 2 &]|| || ||select(x -> x > 2, [1, 2, 3])||
||[[# reduce]][#reduce-note reduce] _
@<&nbsp;>@||Fold[Plus, 0, {1, 2, 3}]|| || || ||
||[[# universal-existential-test]][#universal-existential-test-note universal and existential tests]||##gray|//none//##|| || || ||
||[[# min-max-elem]][#min-max-elem-note min and max element]||Min[{1, 2, 3}] _
Max[{1, 2, 3}]|| ||Minimum([1, 2, 3]) _
Maximum([1, 2, 3])||vecmin([1, 2, 3]) _
vecmax([1, 2, 3])||
||[[# shuffle-sample]][#shuffle-sample-note shuffle and sample]||x = {3, 7, 5, 12, 19, 8, 4} _
 _
RandomSample[x] _
RandomSample[x, 3]|| ||Shuffle([1, 2, 3, 4])|| ||
||[[# flatten]][#flatten-note flatten] _
##gray|//one level, completely//##||Flatten[{1, {2, {3, 4}}}, 1] _
Flatten[{1, {2, {3, 4}}}]|| ||##gray|# completely:## _
Flat([1, [2, [3, 4]]])|| ||
||[[# zip]][#zip-note zip]||##gray|(* list of six elements: *)## _
Riffle[{1, 2, 3}, {"a", "b", "c"}] _
 _
##gray|(* list of lists with two elements: *)## _
Inner[List, {1, 2, 3}, {"a", "b", "c"}, List] _
 _
##gray|(* same as Dot[{1, 2, 3}, {2, 3, 4}]: *)## _
Inner[Times, {1, 2, 3}, {2, 3, 4}, Plus]|| || || ||
||[[# cartesian-product]][#cartesian-product-note cartesian product]||Outer[List, {1, 2, 3}, {"a", "b", "c"}]|| ||Cartesian([1, 2, 3], ["a", "b", "c"])|| ||
||||||||||~ [[# arith-seq]][#arith-seq-note arithmetic sequences]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[#range unit difference]||Range[1, 100]||range(1, 101)||[1 .. 100]||[1 .. 100] _
vector(100, i, i)||
||[#arithmetic-sequence-integer difference of 10]||Range[1, 100, 10]||range(1, 100, 10)||[1,11 .. 91]||vector(10, i, 10 * i  - 9)||
||[#airthmetic-sequence-float difference of 0.1]||Range[1, 100, .1]|| ||##gray|//none//##||vector(1000 - 9, i, i / 10 + 9 / 10)||
||||||||||~ [[# dictionaries]][#dictionaries-note dictionaries]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# dict-literal]][#dict-literal-note literal] _
@<&nbsp;>@||d = <|"t" -> 1, "f" -> 0|> _
 _
##gray|(* or convert list of rules: *)## _
d = Association[{"t" -> 1, "f" -> 0}] _
##gray|(* and back to list of rules: *)## _
Normal[d]||##gray|//use//## [[[scripting#dictionaries|Python dictionaries]]]||##gray|# dictionary constructor; type of keys derived _
# from first arg:## _
d := NewDictionary("", true); _
AddDictionary(d, "t", 1); _
AddDictionary(d, "f", 0); _
 _
##gray|# record literal with identifier keys: ## _
r := rec(t := 1, f := 0); _
 _
##gray|# record literal with string keys:## _
r2 := rec(("t") := 1, ("f") := 0);|| ||
||[[# dict-size]][#dict-size-note size] _
@<&nbsp;>@||Length[Keys[d]]|| ||##gray|# no way to get size of dictionary?## _
  _
Length(RecNames(r));|| ||
||[[# dict-lookup]][#dict-lookup-note lookup] _
@<&nbsp;>@||d["t"]|| ||LookupDictionary(d, "t"); _
 _
##gray|# the same key can be looked up with identifier _
# or string notation:## _
r.t; _
r.("t");|| ||
||[[# dict-update]][#dict-update-note update]||d["f"] = -1|| ||AddDictionary(d, "f", -1); _
 _
r.f := -1; _
r2.("f") := -1;|| ||
||[[# dict-missing-key]][#dict-missing-key-note missing key behavior] _
@<&nbsp;>@||##gray|//Returns a symbolic expression with head "Missing".  If the lookup key was "x", the expression is:// _
 _
@<&nbsp;&nbsp;>@Missing["KeyAbsent", "x"]##|| ||##gray|# returns special object "fail":## _
LookupDictionary(d, "not_a_key"); _
 _
##gray|# raises an error:## _
r.not_a_key;|| ||
||[[# dict-key-check]][#dict-key-check-note is key present] _
@<&nbsp;>@||KeyExistsQ[d, "t"]|| ||KnowsDictionary(d, "t"); _
 _
##gray|# RecNames returns keys as strings:## _
"t" in RecNames(r);|| ||
||[[# dict-iter]][#dict-iter-note iterate] _
@<&nbsp;>@|| || ||##gray|# no way to iterate over dictionary?## _
 _
for i in RecNames(r) do _
@<&nbsp;&nbsp;>@Print(r.(i)); _
od;|| ||
||[[# dict-key-val]][#dict-key-val-note keys and values as arrays]||Keys[d] _
Values[d]|| ||RecNames(r);|| ||
||[[# dict-sort-values]][#dict-sort-values-note sort by values]||Sort[d]|| || || ||
||||||||||~ [[# functions]][#functions-note functions]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[#function-definition define function]||Add[a_, b_] := a + b _
 _
##gray|(* alternate syntax: *)## _
Add = Function[{a, b}, a + b]|| ||add := function(x, y) _
@<&nbsp;&nbsp;>@return x + y; _
end;||add(x, y) = x + y _
 _
##gray|@@\\@@ function body w/ sequence of statements:## _
say(s1, s2, s3) = print(s1); print(s2); print(s3) _
 _
##gray|@@\\@@ function body w/ newlines:## _
dire(s1, s2, s3) = { _
@<&nbsp;&nbsp;>@print(s1); _
@<&nbsp;&nbsp;>@print(s2); _
@<&nbsp;&nbsp;>@print(s3); _
}||
||[#function-invocation invoke function]||Add[3, 7] _
 _
Add @<@@>@ {3, 7} _
 _
##gray|(* syntax for unary functions: *)## _
2 @@//@@ Log|| ||add(3, 7);||add(3, 7)||
||[[# boolean-func-attr]][#boolean-func-attr-note boolean function attributes] _
##gray|//list, set, clear//##||Attributes[add] _
SetAttributes[add, {Orderless, Flat, Listable}] _
ClearAtttibutes[add, Listable]|| || || ||
||[[# undef-func]][#undef-func-note undefine function]||Clear[Add]|| || ||kill(add)||
||[[# redefine-func]][#redefine-func-note redefine function]||Add[a_, b_] := b + a|| || ||add(x, y, z) = x + y + z||
||[[# overload-func]][#overload-func-note overload function]|| || || ||##gray|//none//##||
||[[# missing-func]][#missing-func-note missing function behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##|| || ||##gray|//"not a function" error//##||
||[[# missing-arg]][#missing-arg-note missing argument behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##|| || ||##gray|//set to zero//##||
||[[# extra-arg]][#extra-arg-note extra argument behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##|| || ||##gray|//"too many parameters" error//##||
||[[# default-arg]][#default-arg-note default argument]||Options[myLog] = {base -> 10} _
myLog[x_, OptionsPattern[]] := _
@<&nbsp;&nbsp;>@N[Log[x]/Log[OptionValue[base]]] _
 _
##gray|(* call using default: *)## _
myLog[100] _
 _
##gray|(* override default: *)## _
myLog[100, base -> E]|| || ||mylog(x = 1, base = 10) = log(x) / log(base) _
 _
##gray|@@\\@@ log10(3):## _
mylog(3) _
##gray|@@\\@@ ln(3):## _
mylog(3, exp(1)) _
##gray|@@\\@@ ln(1):## _
mylog(, exp(1)) _
 _
##gray|@@\\@@ If neither caller nor function definition _
@@\\@@ provide a value, zero is used.##||
||[[# retval]][#retval-note return value]||##gray|//last expression evaluated, or argument of// Return[]##|| || || ||
||[#anonymous-function anonymous function]||Function[{a, b}, a + b] _
 _
(#1 + #2) &|| ||##gray|# unary functions only?## _
f := x -> x * x; _
 _
f2 := function(x, y) return 2 * x + 3 * y; end;||f = (x, y) -> x + y _
 _
f(1, 2)||
||[#variable-number-arguments variable number of arguments]||##gray|(* one or more arguments: *)## _
add[a@@__@@] := Plus[a] _
 _
##gray|(* zero or more arguments: *)## _
add[a@@___@@] := Plus[a]|| || || ||
||[[# expand-array]][#expand-array-note pass array elements as separate arguments]||Apply[f, {a, b, c}] _
 _
f @<@@>@ {x, y, z}||a = [x, y, z] _
f(*a)|| || ||
||||||||||~ [[# execution-control]][#execution-control-note execution control]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[#if if]||If[x > 0, _
@<&nbsp;&nbsp;>@Print["positive"], _
@<&nbsp;&nbsp;>@If[x < 0, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Print["negative"], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Print["zero"]]]||##gray|//use//## [http://hyperpolyglot.org/scripting#execution-control Python execution control]||if x > 0 then _
@<&nbsp;&nbsp;>@Print("positive\n"); _
elif x < 0 then _
@<&nbsp;&nbsp;>@Print("negative\n"); _
else _
@<&nbsp;&nbsp;>@Print("zero\n"); _
fi;||if(x > 0, \ _
@<&nbsp;&nbsp;>@print("positive"), \ _
@<&nbsp;&nbsp;>@if(x < 0, \ _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@print("negative"), \ _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@print("zero")))||
||[#while while]||i = 0 _
While[i < 10, Print[i]; i++]|| ||i := 0; _
while i < 10 do _
@<&nbsp;&nbsp;>@Print(i, "\n"); _
@<&nbsp;&nbsp;>@i := i + 1; _
od;||i = 0 _
while(i < 10, print(i); i++)||
||[#for for]||For[i = 0, i < 10, i++, Print[i]]|| ||for i in [0..9] do _
@<&nbsp;&nbsp;>@Print(i, "\n"); _
od;||for(i = 0, 9, print(i))||
||[#break break]||Break[]|| ||break||break||
||[#continue continue]||Continue[]|| ||continue||next||
||||||||||~ [[# exceptions]][#exceptions-note exceptions]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# raise-exc]][#raise-exc-note raise exception]||Throw["failed"]||##gray|//use//## [http://hyperpolyglot.org/scripting#exceptions Python exceptions]||Error("failed");||error("failed")||
||[[# handle-exc]][#handle-exc-note handle exception]||Print[Catch[Throw["failed"]]]|| || ||iferr(error("failed"), E, \ _
@<&nbsp;&nbsp;>@print(errname(E), ": ", component(E, 1)))||
||[[# uncaught-exc]][#uncaught-exc-note uncaught exception behavior]|| || ||##gray|Error() //invokes the GAP debugger.  Type// _
 _
@<&nbsp;&nbsp;>@Quit; _
 _
//to return to REPL.//##|| ||
||||||||||~ [[# streams]][#streams-note streams]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# std-file-handles]][#std-file-handles-note standard file handles]||Streams["stdout"] _
Streams["stderr"] _
 _
##gray|(* all open file handles: *)## _
Streams[]|| || || ||
||[[# write-line-stdout]][#write-line-stdout-note write line to stdout]||Print["hello"]|| ||Print("hello");||print("hello")||
||[[# open-file]][#open-file-note open file for reading]||f  = OpenRead["/etc/hosts"]|| || || ||
||[[# open-file-write]][#open-file-write-note open file for writing]||f = OpenWrite["/tmp/test"]|| || || ||
||[[# open-file-append]][#open-file-append-note open file for appending]||f = OpenAppend["/tmp/test"]|| || || ||
||[[# close-file]][#close-file-note close file]||Close[f]|| || || ||
||[[# read-file-str]][#read-file-str-note read file into string]||s = ReadString[f]|| || || ||
||[[# write-str]][#write-str-note write string]||WriteString[f, "lorem ipsum"]|| || || ||
||[#read-file-string-array read file into array of strings]||s = Import["/etc/hosts"] _
a = StringSplit[s, "\n"]|| || ||a = readstr("/etc/hosts")||
||[[# seek]][#seek-note file handle position] _
 _
##gray|//get, set//##||f = StringToStream["foo bar baz"] _
 _
StreamPosition[f] _
 _
##gray|(* beginning of stream: *)## _
SetStreamPosition[f, 0] _
##gray|(# end of stream: *)## _
SetStreamPosition[f, Infinity]|| || || ||
||[[# tmp-file]][#tmp-file-note open temporary file]||f = OpenWrite[] _
path = Part[f, 1]|| || || ||
||||||||||~ [[# files]][#files-note files]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# file-test]][#file-test-note file exists test, regular file test]||FileExistsQ["/etc/hosts"] _
FileType["/etc/hosts"] == File|| ||IsExistingFile("/etc/hosts");|| ||
||[[# file-size]][#file-size-note file size]||FileByteCount["/etc/hosts"]|| || || ||
||[[# readable-writeable-executable]][#readable-writable-executable-note is file readable, writable, executable]|| || ||IsReadableFile("/etc/hosts"); _
IsWritableFile("/etc/hosts"); _
IsExecutableFile("/etc/hosts");|| ||
||[[# last-modification-time]][#last-modification-time-note last modification time]||FileDate["/etc/hosts"]|| || || ||
||[[# file-cp-rm-mv]][#file-cp-rm-mv-note copy file, remove file, rename file]||CopyFile["/tmp/foo", "/tmp/bar"] _
DeleteFile["/tmp/foo"] _
RenameFile["/tmp/bar", "/tmp/foo"]|| || || ||
||||||||||~ [[# directories]][#directories-note directories]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# working-dir]][#working-dir-note working directory]||dir = Directory[] _
 _
SetDirectory["/tmp"]|| || || ||
||[[# build-pathname]][#build-pathname-note build pathname]||FileNameJoin[{"/etc", "hosts"}]|| || || ||
||[[# dirname-basename]][#dirname-basename-note dirname and basename]||DirectoryName["/etc/hosts"] _
FileBaseName["/etc/hosts"]|| || || ||
||[[# absolute-pathname]][#absolute-pathname-note absolute pathname]||##gray|(* file must exist; _
@<&nbsp;&nbsp;&nbsp;>@symbolic links are resolved: *)## _
AbsoluteFileName["foo"] _
AbsoluteFileName["/foo"] _
AbsoluteFileName["../foo"] _
AbsoluteFileName["./foo"] _
AbsoluteFileName["~/foo"]|| || || ||
||[[# glob]][#glob-note glob paths]||Function[x, Print[x]] /@ FileNames["/tmp/*"]|| || || ||
||[[# mkdir]][#mkdir-note make directory]||CreateDirectory["/tmp/foo.d"]|| || || ||
||[[# recursive-cp]][#recursive-cp-note recursive copy]||CopyDirectory["/tmp/foo.d", "/tmp/baz.d"]|| || || ||
||[[# rmdir]][#rm-dir-note remove empty directory]||DeleteDirectory["/tmp/foo.d"]|| || || ||
||[[# rm-rf]][#rm-rf-note remove directory and contents]||DeleteDirectory["/tmp/foo.d", _
@<&nbsp;&nbsp;>@DeleteContents -> True]|| || || ||
||[[# dir-test]][#dir-test-note directory test]||DirectoryQ["/etc"]|| ||IsDirectoryPath("/etc");|| ||
||||||||||~ [[# libraries-namespaces]][#libraries-namespaces-note libraries and namespaces]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# load-lib]][#load-lib-note load library]||Get["foo.m"]|| ||Read('foo.g');|| ||
||||||||||~ [[# reflection]][#reflection-note reflection]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[#list-function-documentation list function documentation]|| || || ||?||
||[#function-documentation get function documentation]||?Tan _
Information[Tan]||print(sympy.solve.@@__doc__@@) _
 _
##gray|# in IPython:## _
sympy.solve? _
help(sympy.solve)|| ||? tan||
||list function options||Options[Solve] _
Options[Plot]|| || || ||
||[#data-type query data type]||Head[x]|| || ||type(x)||
||list types|| || || ||\t||
||[#list-variables list variables in scope]||Names[$Context <> "*"]|| || ||variable()||
||list built-in functions|| || || ||?*||
||list metacommands|| || || ||?\||
||search documentation|| || ||??DirectProduct||??? modulus||
||||||||||~ [[# vectors]][#vectors-note vectors]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# vec-literal]][#vec-literal-note vector literal]||##gray|(* row vector is same as array: *)## _
{1, 2, 3}||##gray|# column vector:## _
sympy.Matrix([1, 2, 3])||##gray|# row vector is same as array:## _
[1, 2, 3]||[1, 2, 3]||
||[[# const-vec]][#const-vec-note constant vector] _
 _
##gray|//all zeros, all ones//##||Table[0, {i, 1, 100}] _
Table[1, {i, 1, 100}]|| || ||vector(100, i, 0) _
vector(100, i, 1)||
||[[# vec-coordinate]][#vec-coordinate-note vector coordinate]||##gray|(* indices start at one: *)## _
{1,v2, 3}[[1]]|| ||vec := [1, 2, 3]; _
##gray|# indices start at one:## _
v[1];||##gray|@@\\@@ indices start at one:## _
[1, 2, 3][1]||
||[[# vec-dim]][#vec-dim-note vector dimension] _
@<&nbsp;>@||Length[{1, 2, 3}]|| ||Length([1, 2, 3])||length([1, 2, 3]) _
#[1, 2, 3]||
||[[# vec-element-wise]][#vec-element-wise-note element-wise arithmetic operators]||+ - * / _
##gray|//adjacent lists are multiplied element-wise//##|| ||+ - * /||+ -||
||[[# vec-length-mismatch]][#vec-length-mismatch-note vector length mismatch] _
@<&nbsp;>@||##gray|//error//##|| ||##gray|//shorter vector is zero-padded//##||##gray|//error//##||
||[[# vec-scalar]][#vec-scalar-note scalar multiplication]||3 {1, 2, 3} _
{1, 2, 3} 3 _
##gray|//* may also be used//##|| ||3 * [1, 2, 3]; _
[1, 2, 3] * 3;||3 * [1, 2, 3] _
[1, 2, 3] * 3||
||[[# vec-dot]][#vec-dot-note dot product]||{1, 1, 1} . {2, 2, 2} _
Dot[{1, 1, 1}, {2, 2, 2}]||v1 = sympy.Matrix([1, 1, 1]) _
v2 = sympy.Matrix([2, 2, 2]) _
v1.dot(v2)||[1, 1, 1] * [2, 2, 2]||[1, 1, 1] * [2, 2, 2] ~||
||[[# vec-cross]][#vec-cross-note cross product]||Cross[{1, 0, 0}, {0, 1, 0}]||e1 = sympy.Matrix([1, 0, 0]) _
e2 = sympy.Matrix([0, 1, 0]) _
e1.cross(e2)|| || ||
||[[# vec-norms]][#vec-norms-note norms]||Norm[{1, 2, 3}, 1] _
Norm[{1, 2, 3}] _
Norm[{1, 2, 3}, Infinity]||vec = sympy.Matrix([1, 2, 3]) _
 _
vec.norm(1) _
vec.norm() _
vec.norm(inf)|| ||vec = [1, 2, 3] _
 _
normlp(vec, 1) _
normlp(vec, 2) _
normlp(vec)||
||[[# orthonormal-basis]][#orthonormal-basis-note orthonormal basis]||Orthogonalize[@@{{1, 0, 1}, {1, 1, 1}}@@]|| || || ||
||||||||||~ [[# matrices]][#matrices-note matrices]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||literal||##gray|(* used a nested array for each row: *)## _
@@{{@@1, 2}, {3, 4@@}}@@ _
 _
##gray|(* display as grid with aligned columns: *)## _
MatrixForm[@@{{@@1, 2}, {3, 4@@}}@@]||sympy.Matrix([[1, 2], [3, 4]])||[[1, 2], [3, 4]]||[1, 2; 3, 4] _
 _
##gray|@@\\@@ from rows:## _
row1 = [1, 2] _
row2 = [3, 4] _
matconcat([row1; row2])||
||construct from sequence||ArrayReshape[{1, 2, 3, 4, 5, 6}, {2, 3}]||sympy.Matrix(2, 3, [1, 2, 3, 4, 5, 6])|| || ||
||construct from columns|| || || ||col1 = [1, 3]~ _
col2 = [2, 4]~ _
matconcat([col1, col2])||
||construct from submatrices|| || || ||A = [1, 2; 3, 4] _
B = [4, 3; 2, 1] _
##gray|@@\\@@ 4x4 matrix:## _
C = matconcat([A, B; B, A])||
||constant matrices||Table[0, {i, 3}, {j, 3}] _
Table[1, {i, 3}, {j, 3}]||sympy.zeros(3, 3) _
sympy.ones(3, 3)|| ||matrix(3, 3, i, j, 0) _
matrix(3, 3, i, j, 1) _
 _
##gray|@@\\@@ 3x3 Hilbert matrix:## _
matrix(3, 3, i, j, 1 / (i + j - 1))||
||diagonal matrices _
##gray|//and identity//##||DiagonalMatrix[{1, 2, 3}] _
IdentityMatrix[3]||sympy.diag(*[1, 2, 3]) _
sympy.eye(3)||DiagonalMat([1, 2, 3]) _
IdentityMat(3)||matdiagonal([1, 2, 3]) _
matid(3)||
||dimensions||##gray|(* returns {3, 2}: *)## _
Dimensions[@@{{1, 2}, {3, 4}, {5, 6}}@@]||A = sympy.matrix([[1, 2], [3, 4], [5, 6]]) _
 _
##gray|# returns (3, 2):## _
A.shape||##gray|# returns [3, 2]:## _
DimensionsMat([[1, 2], [3, 4], [5, 6]])||##gray|@@\\@@ [3, 2]:## _
matsize([1, 2; 3, 4; 5, 6])||
||element lookup||##gray|(* top left corner: *)## _
@@{{1, 2}, {3, 4}}@@[[1, 1]]||A = sympy.Matrix([[1, 2], [3, 4]]) _
 _
##gray|# top left corner:## _
A[0, 0]||A := [[1, 2], [3, 4]];  _
 _
##gray|# top left corner:## _
A[1][1]||##gray|@@\\@@ top left corner:## _
A[1, 1]||
||extract row||##gray|(* first row: *)## _
@@{{1, 2}, {3, 4}}@@[[1]]||##gray|# first row:## _
A[0, :]|| ||##gray|@@\\@@ first row:## _
[1, 2; 3, 4][1, ]||
||extract column||##gray|(* first column as array: *)## _
@@{{1, 2}, {3, 4}}@@[[All, 1]]||##gray|# first column as 1x2 matrix:## _
A[:, 0]|| ||##gray|@@\\@@ first column:## _
[1, 2; 3, 4][, 1]||
||extract submatrix||A = @@{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}@@ _
A[[1;;2, 1;;2]]||rows = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] _
A = sympy.Matrix(rows) _
A[0:2, 0:2]|| ||A = [1, 2, 3; 4, 5, 6; 7, 8, 9] _
 _
vecextract(A, "1..2", "1..2")||
||element-wise operators||+ - * / _
##gray|//adjacent matrices are multiplied element-wise//##||+ - _
 _
##gray|# for Hadamard product:## _
A.multiply_elementwise(B)||+ -||+ -||
||product||A = @@{{1, 2}, {3, 4}}@@ _
B = @@{{4, 3}, {2, 1}}@@ _
Dot[A, B] _
##gray|(* or use period: *)## _
A . B||A = sympy.matrix([[1, 2], [3, 4]]) _
B = sympy.matrix([[4, 3], [2, 1]]) _
A * B||A := [[1, 2], [3, 4]]; _
B := [[4, 3], [2, 1]]; _
A * B;||A = [1, 2; 3, 4] _
B = [4, 3; 2, 1] _
A * B||
||power||MatrixPower[@@{{1, 2}, {3, 4}}@@, 3] _
 _
##gray|(* element-wise operator: *)## _
A ^ 3||A ** 3|| [[1, 2], [3, 4]] ^ 3||[1, 2; 3, 4] ^ 3||
||exponential||MatrixExp[@@{{1, 2}, {3, 4}}@@]|| || || ||
||log||MatrixLog[@@{{1, 2}, {3, 4}}@@]|| || || ||
||kronecker product||A = @@{{1, 2}, {3, 4}}@@ _
B = @@{{4, 3}, {2, 1}}@@ _
KroneckerProduct[A, B]|| ||A := [[1, 2], [3, 4]]; _
B := [[4, 3], [2, 1]]; _
KroneckerProduct(A, B);|| ||
||norms||A = @@{{1, 2}, {3, 4}}@@ _
 _
Norm[A, 1] _
Norm[A, 2] _
Norm[A, Infinity] _
Norm[A, "Frobenius"]|| || || ||
||transpose||Transpose[@@{{1, 2}, {3, 4}}@@] _
 _
##gray|(* or ESC tr ESC for T exponent notation *)##||A.T|| ||A~ _
mattranspose(A)||
||conjugate transpose||A = @@{{1, I}, {2, -I}}@@ _
ConjugateTranspose[A] _
 _
##gray|(* or ESC ct ESC for dagger exponent notation *)##||M = sympy.Matrix([[1, sympy.I], [2, -sympy.I]]) _
M.adjoint()|| ||conj([1, I; 2, -I] ~)||
||inverse||Inverse[@@{{1, 2}, {3, 4}}@@]||A.inv()||Inverse([[1, 2], [3, 4]])||[1, 2; 3, 4] ^ -1 _
1 /  [1, 2; 3, 4]||
||row echelon form||RowReduce[@@{{1, 1}, {1, 1}}@@]|| || || ||
||pseudoinverse||PseudoInverse[@@{{1, 0}, {3, 0}}@@]|| || || ||
||determinant||Det[@@{{1, 2}, {3, 4}}@@]||A.det()||Determinant([[1, 2], [3, 4]])||matdet([1, 2; 3, 4])||
||trace||Tr[@@{{1, 2}, {3, 4}}@@]|| ||Trace([[1, 2], [3, 4]])||trace([1, 2; 3, 4])||
||rank||MatrixRank[@@{{1, 1}, {0, 0}}@@]|| ||RankMat([[1, 1], [0, 0]])||matrank([1, 1; 0, 0])||
||nullspace basis||NullSpace[@@{{1, 1}, {0, 0}}@@]|| || ||matker([1, 1; 0, 0])||
||range basis|| || ||matimage([1, 1; 0, 0])||
||eigenvalues||Eigenvalues[@@{{1, 2}, {3, 4}}@@]||A.eigenvals()|| ||[vals, vecs] = mateigen([1, 2; 3, 4], flag=1)||
||eigenvectors||Eigenvectors[@@{{1, 2}, {3, 4}}@@]||A.eigenvects()|| ||mateigen([1, 2; 3, 4])||
||singular value decomposition||SingularValueDecomposition[@@{{1, 1}, {1, 0}}@@]|| || || ||
||qr decomposition||QRDecomposition[@@{{1, 2}, {3, 4}}@@]|| || ||matqr([1, 2; 3, 4])||
||solve system of equations|| || || ||A = [1, 2; 3, 4] _
matsolve(A, [2, 3]~)||
||||||||||~ [[# symbolic-expr]][#symbolic-expr-note symbolic expressions]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||simplify||Simplify[Cos[x]^2 + Sin[x]^2] _
 _
##gray|(* perform more simplications: *)## _
FullSimplify[-(1/2) I E^(-I x) (-1 + E^(2 I x))]||sympy.simplify(sympy.cos(x)@@**@@2 + sympy.sin(x)@@**@@2)|| || ||
||simplify with assumption||Simplify[Sqrt[x^2], Assumptions -> x >= 0] _
Simplify[(-1)^(n * (n + 1)), _
@<&nbsp;&nbsp;>@Assumptions -> n \[Element] Integers] _
 _
##gray|(* perform fewer simplications: *)## _
Refine[Sqrt[x^2], Assumptions -> x >= 0] _
Refine[(-1)^(n * (n + 1)), n \[Element] Integers]|| || || ||
||apply rule||##gray|(* {3, 3}: *)## _
ReplaceAll[{x, x}, x -> 3] _
 _
##gray|(* {3, 3}: *)## _
{x, x} /. x -> 3|| || || ||
||replace head||Apply[Times, Plus[x, 3]] _
Times @<@@>@ Plus[x, 3] _
Times @<@@>@ (x + 3)|| || || ||
||prevent simplification||HoldForm[1 + 2] _
 1 + 2 @@//@@ HoldForm|| || || ||
||list evaluation steps||Trace[Apply[And, Map[EvenQ, {2, 3, 4}]]]|| || || ||
||||||||||~ [[# calculus]][#calculus-note calculus]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# limit]][#limit-note limit] _
@<&nbsp;>@||Limit[Sin[x]/x, x -> 0]||sympy.limit(sympy.sin(x)/x, x, 0)|| || ||
||[[# limit-at-infinity]][#limit-at-infinity-note limit at infinity] _
@<&nbsp;>@||Limit[1/x, x -> Infinity]||sympy.limit(1/x, x, sympy.oo)|| || ||
||[#derivative derivative]||D[x^3 + x + 3, x] _
 _
D[x^3 + x + 3, x] /. x -> 2||sympy.diff(x@@**@@3 + x + 3, x) _
 _
sympy.diff(x@@**@@3 + x + 3, x).subs(x, 2)|| ||P = x^3 + x + 3 _
P' _
sin(x)' _
deriv(y^2 + 2, y)||
||[[# derivative-func]][#derivative-func-note derivative of a function]||f[x_] = x^3 + x + 3 _
 _
f'[2] _
Derivative[1][f][2]|| || || ||
||[[# derivative-const]][#derivative-const-note constants]||##gray|(* a depends on x; b does not: *)## _
D[a x + b, x,  NonConstants -> {a}] _
 _
Dt[a x + b, x, Constants -> {b}]|| || || ||
||[#higher-order-derivative higher order derivative]||D[Log[x], {x, 3}] _
Log'''[x] _
Derivative[3][Log][x]||sympy.diff(sympy.log(x), x, 3)|| || ||
||[[# mixed-partial-derivative]][#mixed-partial-derivative-note mixed partial derivative]||D[x^9 * y^8, x, y, y] _
D[x^9 * y^8, x, {y, 2}]||sympy.diff(x@@**@@9 * y@@**@@8, x, y, y)|| || ||
||[[# div-grad-curl]][#div-grad-curl-note div, grad, and curl]||Div[{x^2, x y, x y z}, {x, y, z}] _
 _
Grad[2 x y z^2, {x, y, z}] _
 _
Curl[{x y, y^2}, {x, y}]|| || || ||
||[#antiderivative antiderivative] _
@<&nbsp;>@||Integrate[x^3 + x + 3, x]||sympy.integrate(x@@**@@3 + x + 3, x)|| || ||
||[#integration definite integral] _
@<&nbsp;>@||Integrate[x^3 + x + 3, {x, 0, 1}]||sympy.integrate(x@@**@@3 + x + 3, [x, 0, 1])|| || ||
||[#improper-integral improper integral] _
@<&nbsp;>@||Integrate[Exp[-x], {x, 0, Infinity}]||sympy.integrate(sympy.exp(-x), (x, 0, sympy.oo))|| || ||
||[[# residue]][#residue-note residue]||Residue[1/(z - I), {z, I}]|| || || ||
||series sum||Sum[2^-n, {n, 1, Infinity}]|| || || ||
||power series||Plus @@ Table[x^i / i!, {i, 0, 10}] + O[x]^11|| || || ||
||power series of function||Series[Cos[x], {x, 0, 10}]||sympy.series(sympy.cos(x), x, n=11)|| ||\ps 10 _
Ser(cos(x))||
||||||||||~ [[# equations-unknowns]][#equations-unknowns-note equations and unknowns]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[#solution solution to an equation]||Solve[x^3 + x + 3 == 0, x]||solve(x@@**@@3 + x + 3, x)|| ||solve(x=-10, 10, x^3 + x + 3)||
||[#solution-two-eqn solution to multiple equations]||Solve[x + y == 3 &&  x == 2y, _
@<&nbsp;&nbsp;>@{x, y}]||solve([x + y - 3, 3*x - 2*y], [x, y])|| || ||
||[#solve-diophantine solve diophantine equation]||Solve[a^2 + b^2 == c^2 && _
a > 0  && a < 10 && _
b > 0 && b < 10 && _
c > 0 && c < 10, _
{a, b, c}, Integers]|| || || ||
||differential equation||DSolve[y'[x] == y[x], y[x], x]|| || || ||
||differential equation with boundary condition||DSolve[{y'[x] == y[x], y[0] == 1}, y[x], x]|| || || ||
||system of differential equations|| || || || ||
||recurrence equation||RSolve[{a[n + 2] == a[n + 1] + a[n], a[0] == 1, a[1] == 1}, a[n], n]|| || || ||
||||||||||~ [[# optimization]][#optimization-note optimization]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# minimize]][#minimize-note minimize]||##gray|(* returns list of two items: min value and rule _
@<&nbsp;&nbsp;&nbsp;>@transforming x to argmin *)## _
Minimize[x^2 + 1, x] _
 _
##gray|(* 2 ways to get min value: *)## _
Minimize[x^2 + 1, x][[1]] _
MinValue(x^2 + 1, x] _
 _
##gray|(* 2 ways to get argmin: *)## _
x /. Minimize[x^2 + 1, x][[2]] _
ArgMin[x^2 + 1, x]|| || || ||
||[[# maximize]][#maximize-note maximize]||Maximize[-x^4 + 3 x^3, x] _
 _
Maxvalue[-x^4 + 3 x^3, x] _
ArgMax[-x^4 + 3 x^3, x]|| || || ||
||[[# optimize-unknown-param]][#optimize-unknown-param-note objective with unknown parameter]||##gray|(* minval and argmin are expressions _
@<&nbsp;&nbsp;&nbsp;>@containing a: *)## _
Minimize[(x - a)^2 + x, x]|| || || ||
||[[# unbounded-behavior]][#unbounded-behavior-note unbounded behavior]||##gray|(* MaxValue will be Infinity; MinValue will be _
@<&nbsp;&nbsp;&nbsp;>@-Infinity; ArgMax or ArgMin will be _
@<&nbsp;&nbsp;&nbsp;>@Indeterminate *)##|| || || ||
||[[# optimize-multiple-var]][#optimize-multiple-var-note multiple variables]||Minimize[x^4 - 2 x^2 + 2 y^4 - 3 y^2, {x, y}]|| || || ||
||[[# optimize-constraints]][#optimize-constraints-note constraints]||Minimize[{-x - 2 y^2, y^2 <= 17, 2 x + y <= 5}, _
@<&nbsp;&nbsp;>@{x, y}]|| || || ||
||[[# infeasible-behavior]][#infeasible-behavior-note infeasible behavior]||##gray|(* MaxValue will be -Infinity; MinValue will be _
@<&nbsp;&nbsp;&nbsp;>@Infinity; ArgMax or ArgMin will be _
@<&nbsp;&nbsp;&nbsp;>@Indeterminate *)##|| || || ||
||[[# optimize-int-var]][#optimize-int-var-note integer variables]||Maximize[{x^2 + 2*y, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@x >= 0, y >= 0, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@2 x + Pi * y <= 4}, _
@<&nbsp;&nbsp;>@{x, y}, Integers]|| || || ||
||[[# numerical-opt]][#numerical-opt-note numerical optimization]||NMinimize[(x^2 - 3)^2, x _
@<&nbsp;&nbsp;>@MaxIterations -> 100, _
@<&nbsp;&nbsp;>@AccuracyGoal -> 16, _
@<&nbsp;&nbsp;>@PrecisionGoal -> 8, _
@<&nbsp;&nbsp;>@Method -> "NelderMead"] _
 _
##gray|(* precision: total significant digits _
@<&nbsp;&nbsp;&nbsp;>@accuracy: digits right of decimal point *)## _
 _
##gray|(* other methods: "DifferentialEvolution", _
@<&nbsp;&nbsp;&nbsp;>@"SimulatedAnnealing", "RandomSearch" *)##|| || || ||
||[[# local-opt-near-point]][#local-opt-near-point-note local optimum near point]||FindMinimum[x Cos[x], {x, 2} _
@<&nbsp;&nbsp;>@AccuracyGoal -> 16, _
@<&nbsp;&nbsp;>@PrecisionGoal -> 8, _
@<&nbsp;&nbsp;>@Method -> "ConjugateGradient"] _
 _
##gray|(* other method: "PrincipalAxis*)##|| || || ||
||||||||||~ [[# combinatorics]][#combinatorics-note combinatorics]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# factorial]][#factorial-note factorial]||10! _
Factorial[10]||factorial(10)||Factorial(10);||10!||
||falling factorial||FactorialPower[10, 3]|| || ||10! / (10 - 3)!||
||binomial coefficient||Binomial[10, 3]||binomial(10, 3)||Binomial(10, 3);||binomial(10, 3)||
||multinomial coefficient||Multinomial[3, 4, 5]|| || || ||
||integer partitions _
 _
##gray|//and count//##||IntegerPartitions[10] _
 _
Length[IntegerPartitions[10]]|| ||Partitions(10); _
 _
NrPartitions(10);||partitions(10) _
 _
length(partitions(10))||
||set partitions _
 _
##gray|//and Bell number//##||StirlingS2[10, 3] _
BellB[10]|| || ||stirling(10, 3, 2) _
sum(i=1, 10, stirling(10, i, 2))||
||permutations with k disjoint cycles||Abs[StirlingS1[n, k]]|| || ||abs(stirling(n, k, 1))||
||fibonacci number _
 _
##gray|//and lucas number//##||Fibonacci[10] _
LucasL[10]|| || ||fibonacci(10) _
##gray|//??//##||
||bernoulli number||BernoulliB[100]|| || ||bernfrac(100)||
||||||||||~ [[# number-theory]][#number-theory-note number theory]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# pseudoprime-test]][#pseudoprime-test-note pseudoprime test]||PrimeQ[7]||sympy.ntheory.primetest.isprime(7) _
sympy.ntheory.primetest.mr(7, [2, 3])||IsPrimeInt(7);||ispseudoprime(7)||
||[[# true-prime-test]][#true-prime-test-note true prime test] _
@<&nbsp;>@|| || || ||isprime(7)||
||[[# divisors]][#divisors-note divisors]||##gray|(* {1, 2, 4, 5, 10, 20, 25, 50, 100}: *)## _
Divisors[100]||sympy.ntheory.divisors(100)||DivisorsInt(100);||divisors(100)||
||[[# prime-factors]][#prime-factors prime factors]||##gray|(* returns @<{{>@2, 2}, {3, 1}, {7, 1}} *)## _
FactorInteger[84]||##gray|# {2: 2, 3: 1, 7: 1}:## _
sympy.ntheory.factorint(84)||##gray|# [ 2, 2, 3, 7 ]:## _
FactorsInt(84);||##gray|@@\\@@ [2,2; 3,1; 7,1]:## _
factor(84)||
||[[# next-prime]][#next-prime-note next prime] _
 _
##gray|//and preceding//##||NextPrime[1000] _
NextPrime[1000, -1]||sympy.ntheory.generate.nextprime(1000) _
sympy.ntheory.generate.prevprime(1000)||NextPrimeInt(1000); _
PrevPrimeInt(1000);||nextprime(1000) _
precprime(1000)||
||[[# nth-prime]][#nth-prime-note nth prime]||##gray|(* 541: *)## _
Prime[100]||sympy.ntheory.generate.prime(100)|| ||##gray|@@\\@@ first 100 primes: primes(100)## _
primes(100)[100]||
||[[# prime-counting-func]][#prime-counting-func-note prime counting function]||##gray|(* 25: *)## _
PrimePi[100]||sympy.ntheory.generate.primepi(100)|| ||primepi(100)||
||[[# divmod]][#divmod-note divmod] _
@<&nbsp;>@||QuotientRemainder[7, 3]||divmod(7, 3)|| ||divrem(7, 3)||
||[[# gcd]][#gcd-note greatest common divisor] _
 _
##gray|//and relatively prime test//##||GCD[14, 21] _
GCD[14, 21, 777] _
 _
CoprimeQ[14, 21]||sympy.gcd(14, 21) _
sympy.gcd(sympy.gcd(14, 21), 777)||GcdInt(14, 21); _
GcdInt(GcdInt(14, 21), 777);||gcd(14, 21) _
gcd(gcd(14, 21), 777)||
||[[# extended-euclidean-algorithm]][#extended-euclidean-algorithm-note extended euclidean algorithm]||##gray|(* {1, {2, -1}}: *)## _
ExtendedGCD[3, 5]||import sympy.ntheory.modular _
 _
##gray|# (2, -1, 1):## _
sympy.ntheory.modular.igcdex(3, 5)||ret := Gcdex(3, 5); _
 _
##gray|# 2:## _
ret.coeff1; _
##gray|# -1:## _
ret.coeff2; _
##gray|# 1:## _
ret.gcd;||##gray|@@\\@@ [2, -1, 1]:## _
gcdext(3, 5)||
||[[# lcm]][#lcm-note least common multiple]||LCM[14, 21]||sympy.lcm(14, 21)||LcmInt(14, 21);||lcm(14, 21)||
||[[# int-residues]][#int-residues-note integer residues]|| || ||r := ZmodnZ(5); _
fam := ElementsFamily(FamilyObj(r));; _
 _
ZmodnZObj(fam, 2) + ZmodnZObj(fam, 3);||Mod(2, 5) + Mod(3, 5) _
Mod(2, 5) - Mod(3, 5) _
Mod(2, 5) * Mod(3, 5) _
Mod(2, 5)^2||
||[[# mult-inverse]][#mult-inverse-note multiplicative inverse]|| || ||r := ZmodnZ(7); _
fam := ElementsFamily(FamilyObj(r));; _
 _
ZmodnZObj(2, 7)^-1;||Mod(2, 7)^-1 _
 _
##gray|@@\\@@ raises error:## _
Mod(2, 4)^-1||
||[[# chinese-remainder-thm]][#chinese-remainder-thm-note chinese remainder theorem]|| || ||##gray|# 173:## _
ChineseRem([17, 11], [3, 8]);||##gray|@@\\@@ Mod(173, 187):## _
chinese(Mod(3, 17), Mod(8, 11))|||
||[[# lift-int-residue]][#lift-int-residue-note lift integer residue]|| || || ||##gray|@@\\@@ 7:## _
lift(-17, 12) _
##gray|@@\\@@ -5:## _
centerlift(-17, 12)||
||[[# euler-totient]][#euler-totient-note euler totient] _
@<&nbsp;>@||EulerPhi[256]||sympy.ntheory.totient(256)||Phi(256);||eulerphi(256)||
||[[# mult-order]][#mult-order-note multiplicative order]||MultiplicativeOrder[7, 108]|| ||OrderMod(7, 108);||znorder(Mod(7, 108))||
||[[# primitive-roots]][#primitive-roots-note primitive roots]||PrimitiveRoot[11] _
 _
##gray|(* all primitive roots: *)## _
PrimitiveRootList[11]|| ||PrimitiveRootMod(11);||znprimroot(11)||
||[[# discrete-log]][#discrete-log-note discrete logarithm]|| || ||##gray|# arg: 10, base: 2, modulus: 11## _
LogMod(10, 2, 11);||znlog(10, Mod(2, 11)) _
znlog(Mod(10, 11), Mod(2, 11))||
||[[# carmichael-func]][#carmichael-func-note carmichael function]||CarmichaelLambda[561]|| ||Lambda(561);||lcm(znstar(561)[2])||
||[[# kronecker-symbol]][#kronecker-symbol-note kronecker symbol] _
 _
##gray|//and jacobi symbol//##||KroneckerSymbol[3, 5] _
JacobiSymbol[3, 5]|| ||Jacobi(3, 5);||kronecker(3, 5)||
||[[# moebius-func]][#moebius-func-note moebius function]||MoebiusMu[11]|| ||MoebiusMu(11);||moebius(11)||
||[[# riemann-zeta-func]][#riemann-zeta-func-note riemann zeta function]||Zeta[2]||sympy.mpmath.zeta(2)|| ||zeta(2)||
||[[# mangoldt-lambda]][#mangoldt-lambda-note mangoldt lambda]||MangoldtLambda[11]|| || || ||
||[[# dirichlet-char]][#dirichlet-char-note dirichlet character]||Table[DirichletCharacter[2, 1, i], {i, 100}]|| || || ||
||||||||||~ [[# elliptic-curves]][#elliptic-curves-note elliptic curves]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||elliptic curve from coefficients|| || || ||##gray|@@\\@@ ellinit([a, b, c, d, e]) where _
@@\\@@ _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@y^2 + axy + by = x^3 + cx^2 + dx + e _
@@\\@@## _
e0 = ellinit([0,0,1,-7,6]) _
 _
##gray|@@\\@@ ellinit([a, b]) where _
@@\\@@ _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@y^2 = x^3 + ax + b _
@@\\@@## _
e1 = ellinit([-1, 0])||
||discriminant|| || || ||e0.disc||
||conductor|| || || ||ellglobalred(e0)[1]||
||singularity test|| || || ||e0.disc == 0||
||convert to minimal model|| || || ||e0 = ellinit([6, -3, 9, -16, -14]) _
e = ellminimalmodel(e0)||
||coordinate transformation on point|| || || ||e0 = ellinit([6, -3, 9, -16, -14]) _
e = ellminimalmodel(e0, &v) _
##gray|@@\\@@ minimal to original:## _
ellchangepointinv([0, 0], v) _
##gray|@@\\@@ original to minimal:## _
ellchangepoint([-2, 2], v)||
||coordinate transformation on curve: ellchangecurve|| || || ||e0 = ellinit([6, -3, 9, -16, -14]) _
e = ellminimalmodel(e0, &v) _
##gray|@@\\@@ same as e0:## _
ellchangecurve(e, v)||
||point on curve test|| || || ||ellisoncurve(e, [0, 2])||
||abscissa to ordinates|| || || ||##gray|@@\\@@ vector of size 0, 1, or 2:## _
ellordinate(e, 0)||
||group identity|| || || ||[0]||
||group operation|| || || ||elladd(e, [0, 2], [1, -1])||
||group inverse|| || || ||ellneg(e, [0, 2])||
||group multiplication|| || || ||ellmul(e, [0, 2], 3)||
||canonical height of point|| || || ||ellheight(e, [0, -3])||
||order of point|| || || ||##gray|@@\\@@ returns 0 for infinite order:## _
ellorder(e, [0, 2]) _
 _
ellorder(e1, [0, 0])||
||torsion subgroup|| || || ||e1 = ellinit([-1, 0]) _
 _
##gray|@@\\@@ returns [t, v1, v2]: _
@@\\@@ _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@t: order of torsion group _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@v1: orders of component cyclic groups _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@v2: generators of same cyclic groups _
@@\\@@## _
elltors(e1)||
||analytic rank|| || || ||##gray|@@\\@@ first value is rank:## _
[a, b] = ellanalyticrank(e) _
 _
##gray|@@\\@@ recompute second value to higher precision:## _
\p 100 _
b = ellL1(e, a)||
||L-function value|| || || ||elllseries(e, 1 + I)||
||L-function coefficients|| || || ||##gray|@@\\@@ tenth coefficient:## _
ellak(e, 10) _
##gray|@@\\@@ first ten coefficients:## _
ellan(e, 10)||
||||||||||~ [[# rational-algebraic-numbers]][#rational-algebraic-numbers-note rational and algebraic numbers]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||to continued fraction||cf = ContinuedFraction[Pi, 100]|| || ||\p 100 _
contfrac(Pi)||
||from continued fraction||##gray|(* rational approx. of π: *)## _
FromContinuedFraction[cf]|| || || ||
||p-adic number|| || || ||##gray|@@\\@@ p is 2 and precision in powers of 2 is 100:## _
1/2 + O(2^100)||
||lift p-adic to rational|| || || ||lift(1/2 + O(2^100))||
||gaussian integer norm|| || || ||norm(1 + I)||
||quadratic extension|| || || ||##gray|@@\\@@ make w equal to sqrt(D)/4:## _
D = -4 _
w = quadgen(D)||
||quadratic number|| || || ||(1 + w)^2||
||||||||||~ [[# polynomials]][#polynomials-note polynomials]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||from expression with indeterminates||(x - 1) (x - 2) _
 _
(x + 1)^2 (y + 2)^3|| || ||(x - 1) * (x - 2) _
 _
(1+x)^2 * (2+y)^3||
||from coefficient array||coeff = {1, -3, 2} _
Plus @@ Table[coeff[[i]] * x^(3 - i), {i, 1, 3}]|| || ||Pol([1, -3, 2]) _
 _
##gray|@@\\@ zero-degree coefficient first:## _
Polrev([2, -3, 1])||
||to coefficient array||CoefficientList[(x + 1)^10, x]|| || ||Vec((x+1)^10)||
||lookup coefficient||Coefficient[(1 + x)^10, x, 3]|| || ||polcoeff((x+1)^10, 3)||
||substitute indeterminate|| || || ||##gray|@@\\@@ replace x with 3:## _
subst((x-1)*(x-2), x, 3) _
##gray|@@\\@@ replace x with (x-1):## _
subst((x-1)*(x-2), x, (x-1))||
||degree||Exponent[(x + 1)^10, x]|| || ||poldegree((x-1)^10)||
||operations||+ - * /|| || ||+ - * /||
||division and remainder||PolynomialReduce[x^10 - 1, x - 1, {x}] _
PolynomialReduce[x^10 - y^10, x - y, {x, y}]|| || || ||
||[#expand-polynomial expand polynomial]||Expand[(1 + x)^5]||sympy.expand((1+x)@@**@@5)|| || ||
||[#factor-polynomial factor polynomial]||Factor[3 + 10 x + 9 x^2 + 2 x^3]||sympy.factor(3 + 10*x + 9*x@@**@@2 + 2*x@@**@@3)|| || ||
||collect terms||##gray|(* write as polynomial in x: *)## _
Collect[(1 + x + y)^3, x]||sympy.collect(sympy.expand((x+y+1)**3), x)|| || ||
||factor||Factor[x^10 - y^10]|| || ||factor(x^2-1)||
||roots||Solve[x^3 + 3 x^2 + 2 x - 1 == 0, x]|| || ||polroots(x^3+3*x^2+2*x-1)||
||greatest common divisor||p1 = -2 - x + 2 x^2 + x^3 _
p2 = 6 - 7 x + x^3 _
PolynomialGCD[p1, p2]|| || ||p1 = x^3 + 2*x^2 -x -2 _
p2 = x^3 -7*x + 6 _
gcd(p1, p2)||
||resultant||Resultant[(x-1)(x-2), (x-3)(x-3), x]|| || ||polresultant((x-1)*(x-2), (x-3)^2)||
||discriminant||Discriminant[(x + 1) (x - 2), x]|| || ||poldisc((x+1)*(x-2))||
||groebner basis||p1 = x^2 + y + z - 1 _
p2 = x + y^2 + z - 1 _
p3 = x + y + z^2 - 1 _
 _
##gray|(* uses lexographic order by default: *)## _
GroebnerBasis[{p1, p2, p3}, {x, y, z}]|| || ||##gray|//none//##||
||specify ordering|| || || ||##gray|//none//##||
||symmetric polynomial||SymmetricPolynomial[3, {x1, x2, x3, x4}]|| || ||##gray|//none//##||
||cyclotomic polynomial||Cyclotomic[10, x]|| || ||polcyclo(10)||
||hermite polynomial||HermiteH[4, x]|| || ||polhermite(4)||
||chebyshev polynomial _
 _
##gray|//first and second kind//##||ChebyshevT[4, x] _
ChebyshevU[4, x]|| || ||polchebyshev(4, 1) _
polychebyshev(4, 2)||
||interpolation polynomial||pts = Inner[List, {1, 2, 3}, {2, 4, 7}, List] _
InterpolatingPolynomial[pts, x]|| || ||polinterpolate([1, 2, 3], [2, 4, 7])||
||characteristic polynomial||CharacteristicPolynomial[@@{{1, 2}, {3, 4}}@@, x]|| || ||charpoly([1, 2; 3, 4])||
||minimal polynomial|| || || || ||
||piecewise polynomial|| || || || ||
||rational function||(x - 1) / (x - 2)^2|| || ||(x - 1) / (x - 2)^2||
||[#add-fractions add fractions]||Together[a/b + c/d]||sympy.together(x/y + z/w)|| || ||
||[#partial-fraction-decomposition partial fraction decomposition]||Apart[(b c + a d)/(b d)]||##gray|# only one symbol allowed in denominator:## _
sympy.apart((3*x+2) / (x*(x+1)))|| || ||
||||||||||~ [[# trigonometry]][#trigonometry-note trigonometry]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||eliminate sums and multiples inside trig functions||TrigExpand[Sin[2 x + y]]|| || || ||
||eliminate powers of trig functions||TrigReduce[Sin[x]^2]|| || || ||
||trig to complex exponential|| || || || ||
||complex exponential to trig|| || || || ||
||fourier expansion||##gray|(* integrals are over [-π, π] *)## _
f[x_] = Piecewise[@@{{@@0, 0 <= x @@&&@@ x < Pi}, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@{1, -Pi <= x @@&&@@ x < 0@@}}@@] _
 _
##gray|(* in sin and cos: *)## _
FourierTrigSeries[f[x], x, 10] _
 _
##gray|(* in complex exponentials: *)## _
FourierSeries[f[x], x, 10]|| || || ||
||fourier transform||f[ω_] = FourierTransform[ Sin[t], t, ω] _
 _
InverseFourierTransform[f[ω], ω, t]|| || || ||
||||||||||~ [[# special-functions]][#special-functions-note special functions]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||gamma||Gamma[1/2]|| || ||gamma(1/2)||
||hyperbolic||Sinh Cosh Tanh _
ArcSinh ArcCosh ArcTanh|| || ||sinh cosh tanh||
||elliptic integerals||EllipticK EllipticF _
EllipticE _
EllipticPi|| || || ||
||bessel functions||BesselJ _
BesselY _
BesselI _
BesselK|| || ||besselh1 besselh2 besseli besselj besseljh besselk besseln||
||[[# riemann-zeta]][#riemann-zeta-note Riemann zeta]||Zeta[2]|| || ||zeta(2)||
||||||||||~ [[# permutations]][#permutations-note permutations]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||permutation from disjoint cycles||p = Cycles[@@{{1, 2}, {3, 4}}@@]||import sympy.combinatorics as combinatorics _
 _
p = combinatorics.Permutation(0, 1)(2, 3)||p := (1, 2)(3, 4);|| ||
||permutation from list||p = PermutationCycles[{2, 1, 4, 3}]||import sympy.combinatorics as combinatorics _
 _
p = combinatorics.Permutation([1, 0, 3, 2])||p2 := PermList([2, 1, 4, 3]);|| ||
||permutation from two lists||FindPermutation[{a, b, c}, {b, c, a}]|| ||##gray|# must be positive integers:## _
p := MappingPermListList([6, 8, 4, 2], [2, 4, 6, 8])|| ||
||act on element||p = Cycles[@@{{1, 2}, {3, 4}}@@] _
 _
PermutationReplace[1, p]||p(0)||1 ^ p; _
 _
##gray|# preimage of 1 under p:## _
1 / p;|| ||
||act on list||##gray|(* if list is too big, extra elements retain _
@<&nbsp;&nbsp;&nbsp;>@their positions; if list is too small, _
@<&nbsp;&nbsp;&nbsp;>@expression is left unevaluated. *)## _
Permute[{a, b, c, d}, p12n34]||a, b, c, d = sympy.symbols('a b c d') _
  _
p = combinatorics.Permutation(0, 1)(2, 3) _
p([a, b, c, d])|| || ||
||compose||p1 = Cycles[@@{{1, 2}, {3, 4}}@@] _
p2 = Cycles[@@{{1, 3}}@@] _
PermutationProduct[p1, p2]||p1 = combinatorics.Permutation(0, 1)(2, 3) _
p2 = combinatorics.Permutation(0, 2) _
 _
p1 * p2||(1, 2)(3, 4) * (1, 3);|| ||
||invert||InversePermutation[Cycles[@@{{1, 2, 3}}@@]]||p = combinatorics.Permutation(0, 1, 2) _
 _
p ** -1||(1, 2, 3) ^ -1;|| ||
||power||PermutationPower[Cycles[@@{{1, 2, 3, 4, 5}}@@], 3]||p = combinatorics.Permutation(0, 1, 2, 3, 4) _
 _
p ** 3||(1, 2, 3, 4, 5) ^ 3;|| ||
||order||PermutationOrder[Cycles[@@{{1, 2, 3, 4, 5}}@@]]||combinatorics.Permutation(0, 1, 2, 3, 4).order()|| || ||
||support||PermutationSupport[Cycles[@@{{1, 3, 5}, {7, 8}}@@]]||p = combinatorics.Permutation(0, 2, 4)(6, 7) _
 _
p.support()||MovedPoints((1, 3, 5)(7, 8));|| ||
||number of inversions|| ||Permutation(0, 2, 1).inversions()|| || ||
||parity|| ||Permutation(0, 2, 1).parity()|| || ||
||to inversion vector|| ||Permutation(0, 2, 1).inversion_vector()|| || ||
||from inversion vector|| ||Permutation.from_inversion_vector([2, 0])|| || ||
||all permutations||GroupElements[SymmetricGroup[4]] _
 _
##gray|(* of a list: *)## _
Permutations[{a, b, c, d}]|| || || ||
||random permutation||RandomPermutation[10]||Permutation.random(10)|| || ||
||||||||||~ [[# groups]][#groups-note groups]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||group from permutation generators||e1 = Cycles[@@{{1, 3, 5, 2}}@@] _
e2 = Cycles[@@{{1, 2}}@@] _
g := PermutationGroup[{e1, e2}]||from sympy.combinatorics import * _
 _
p1 = Permutation(0, 2, 4, 1) _
p2 = Permutation(0, 1) _
g = PermutationGroup(p1, p2)||g := Group((1, 3, 5, 2), (1, 2)); _
 _
##gray|# or## _
g := GroupWithGenerators([(1, 3, 5, 2), (1, 2)]);|| ||
||named groups _
 _
##gray|//symmetric, alternating, cyclic, dihedral//##||s4 = SymmetricGroup[4] _
a4 = AlternatingGroup[4] _
z5 = CyclicGroup[5] _
d10 = DihedralGroup[10]||from sympy.combinatorics import * _
 _
s4 = SymmetricGroup(4) _
a4 = AlternatingGroup(4) _
z5 = CyclicGroup(5) _
d10 = DihedralGroup(10)||s4 := SymmetricGroup(4); _
a4 := AlternatingGroup(4); _
z5 := CyclicGroup(5); _
d10 := DihedralGroup(2 * 10);|| ||
||groups by size|| || ||AllSmallGroups(8);|| ||
||conjugate group|| || ||ConjugateGroup(SymmetricGroup(4), (4, 5));|| ||
||direct product|| ||from sympy.combinatorics import * _
 _
z3 = CyclicGroup(3) _
a4 = AlternatingGroup(4) _
g = DirectProduct(z3, a4)||z3 := CyclicGroup(3); _
a4 := AlternatingGroup(4); _
g := DirectProduct(z3, a4);|| ||
||free product|| || ||f := FreeProduct(CyclicGroup(3), CyclicGroup(2));|| ||
||free group|| || ||##gray|# integers under addition:## _
z := FreeGroup(1); _
 _
##gray|# free group with 2 generators:## _
f := FreeGroup("a", "b");|| ||
||all elements||GroupElements[DihedralGroup[10]]|| || || ||
||identity element||Cycles[{}]|| ||Identity(g)|| ||
||random element||RandomSample[GroupElements[g], 1][[1]]||g.random()||Random(g)|| ||
||group operation||e1 := RandomSample[GroupElements[g], 1][[1]] _
e2 := RandomSample[GroupElements[g], 1][[1]] _
PermutationProduct[e1, e2]||e1 = g.random() _
e2 = g.random() _
e1 * e2||e1 := Random(g); _
e2 := Random(g); _
e1 * e2;|| ||
||inverse element|| ||e1**-1||Inverse(e1); _
##gray|# or:## _
e1^-1;|| ||
||commutator|| ||##gray|# e2 ** -1 * e1 ** -1 * e2 * e1:## _
e1.commutator(e2)||##gray|# e1^-1 * e2^-1 * e1 * e2:## _
Comm(e1, e2);|| ||
||generators|| ||g.generators||s10 := SymmetricGroup(10); _
##gray|# return generators in an array:## _
GeneratorsOfGroup(s10); _
 _
##gray|# notation for individual generators:## _
s10.1; _
s10.2;|| ||
||express element using generators|| || ||s10 := SymmetricGroup(10); _
Factorization(s10, (1,3,8,10,5,9,2,7));|| ||
||number of elements by generator word length|| || ||s6 := SymmetricGroup(6); _
GrowthFunctionOfGroup(s6);|| ||
||group from finite presentation|| || ||f := FreeGroup( "a", "b" ); _
g := f / [ f.1^2, f.2^3, (f.1 * f.2)^5 ];|| ||
||order of group element|| || ||d10 := DihedralGroup(10); _
 _
Order(d10.1); _
Order(d10.2);|| ||
||order||GroupOrder[g]||g.order()||Size(g)|| ||
||cyclic test|| || ||IsCyclic(AlternatingGroup(10));|| ||
||abelian test|| ||g.is_abelian||IsAbelian(CyclicGroup(10)); || ||
||identify|| || ||StructureDescription(g);|| ||
||cosets|| || ||RightCoset() _
CanonicalRightCosetElement() _
CosetDecomposition() _
RightTraversal(G, U)|| ||
||||||||||~ [[# subgroups]][#subgroups-note subgroups]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||all subgroups|| || ||AllSubgroups(SymmetricGroup(4));|| ||
||subgroup lattice|| || ||s4 := SymmetricGroup(4); _
lat := LatticeSubgroups(s4); _
DotFileLatticeSubgroups(lat, "lattice.dot"); _
##gray|#  dot -Tpng < lattice.dot > lattice.png##|| ||
||maximal subgroups|| || ||MaximalSubgroups(s4);|| ||
||frattini subgroup|| || ||FrattiniSubgroup(DihedralGroup(8));|| ||
||subgroup from generators|| || ||g := Group((1, 3, 5, 7), (2, 4)); _
h := Subgroup(g, [(2, 4)]);|| ||
||normal subgroups|| || ||NormalSubgroups(s4);|| ||
||center|| ||g.center()||g := DirectProduct(CyclicGroup(4), DihedralGroup(6)); _
Center(g);|| ||
||centralizer|| || ||g := SymmetricGroup(5); _
h := Centralizer(g, (1, 3)(4, 5));|| ||
||normalizer|| || ||s4 := SymmetricGroup(4); _
g := Group([(1,2)(3,4)]); _
Normalizer(s4, g);|| ||
||commutator subgroup|| || ||g1 := Group((1,2,3),(1,2)); _
g2 := Group((2,3,4),(3,4)); _
CommutatorSubgroup(g1, g2);|| ||
||subgroup test|| || || || ||
||subgroup index|| || ||Index(g, h);|| ||
||normal test|| || ||IsNormal(g, h);|| ||
||subnormal test|| || ||IsSubnormal(g, h);|| ||
||nonabelian simple groups|| || ||##gray|# argument is list of orders:## _
AllSmallNonabelianSimpleGroups([1..10000]);|| ||
||simple test|| || ||IsSimple(SymmetricGroup(4));|| ||
||solvable test|| ||g.is_solvable||IsSolvable(SymmetricGroup(4));|| ||
||derived series|| ||g.derived_series()||DerivedSeriesOfGroup(SymmetricGroup(4));|| ||
||characteristic test|| || ||s4 := SymmetricGroup(4); _
h := Subgroup(s4, [(1,4)(2,3), (1,3)(2,4), (2,4,3)]); _
IsCharacteristicSubgroup(s4, h);|| ||
||semidirect product|| || || || ||
||||||||||~ [[# group-homomorphisms]][#group-homomorphisms-note group homomorphisms]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||all homomorphisms|| || ||s4 := SymmetricGroup(4); _
s3 := SymmetricGroup(3); _
AllHomomorphisms(s3, s4);|| ||
||all homomorphims classes|| || ||AllHomomorphismClasses(s3, s4);|| ||
||endomorphisms and automorphisms|| || ||AllEndomorphisms(s4); _
AllAutomorphisms(s4);|| ||
||homomorphism from generator images|| || ||hom := GroupHomomorphismByImages(s3, s4, _
@<&nbsp;&nbsp;>@[(1,2,3), (1,2)], _
@<&nbsp;&nbsp;>@[(2,3,4), (2,3)]); _
 _
##gray|# uses generators of s3:## _
hom := GroupHomomorphismByImages(s3, s4, _
@<&nbsp;&nbsp;>@[(2,3,4), (2,3)]);|| ||
||surjective test|| || ||IsSurjective(hom);|| ||
||injective test|| || ||IsInjective(hom);|| ||
||bijective test|| || ||IsBijective(hom);|| ||
||kernel|| || ||Kernel(AllHomomorphisms(s3, s4)[1]);|| ||
||image|| || ||Image(AllHomomorphisms(s3, s4)[1]);|| ||
||||||||||~ [[# actions]][#actions-note actions]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||conjugate element|| || ||##gray|# (1,2,3)^-1 * (1,2) * (1,2,3):## _
(1,2)^(1,2,3)|| ||
||conjugate set|| || ||s3 := SymmetricGroup(3); _
s3^(3,4); _
(3,4)^s3;|| ||
||conjugacy class|| || ||s4: SymmetricGroup(4); _
AsList(ConjugacyClass(s4, (1,2,3)));|| ||
||conjugacy classes|| || ||ConjugacyClasses(SymmetricGroup(4));|| ||
||stabilizer|| || || || ||
||orbit|| || || || ||
||transitive test|| || || || ||
||||||||||~ [[# descriptive-statistics]][#descriptive-statistics-note descriptive statistics]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# first-moment-stats]][#first-moment-stats-note first moment statistics]||vals = {1, 2, 3, 8, 12, 19} _
X = NormalDistribution[0, 1] _
 _
Mean[vals] _
Total[vals] _
Mean[X]|| || || ||
||[[# second-moment-stats]][#second-moment-stats-note second moment statistics]||Variance[X] _
StandardDeviation[X]|| || || ||
||[[# second-moment-stats-sample]][#seond-moment-stats-sample-note second moment statistics for samples]||Variance[vals] _
StandardDeviation[vals]|| || || ||
||[[# skewness]][#skewness-note skewness]||Skewness[vals] _
Skewness[X]|| || || ||
||[[# kurtosis]][#kurtosis-note kurtosis]||Kurtosis[vals] _
Kurtosis[X]|| || || ||
||[[# nth-moment]][#nth-moment-note nth moment and nth central moment]||Moment[vals, 5] _
CentralMoment[vals, 5] _
Moment[X, 5] _
CentralMoment[X, 5] _
 _
MomentGeneratingFunction[X, t]|| || || ||
||[[# cumulant]][#cumulant-note cumulant]||Cumulant[vals, 1] _
Cumulant[X, 1] _
 _
CumulantGeneratingFunction[X, t]|| || || ||
||[[# entropy]][#entropy-note entropy]||Entropy[vals]|| || || ||
||[[# mode]][#mode-note mode]||Commonest[{1, 2, 2, 2, 3, 3, 8, 12}]|| || || ||
||[[# quantile-stats]][#quantile-stats-note quantile statistics]||Min[vals] _
Median[vals] _
Max[vals] _
InterquartileRange[vals] _
Quantile[vals, 9/10]|| || || ||
||[[# bivariate-stats]][#bivariate-stats-note bivariate statistiscs] _
##gray|//correlation, covariance//##||Correlation[{1, 2, 3}, {2, 4, 7}] _
Covariance[{1, 2, 3}, {2, 4, 7}]|| || || ||
||[[# freq-table]][#freq-table-note data set to frequency table]||data = {1, 2, 2, 2, 3, 3, 8, 12} _
##gray|(* list of pairs: *)## _
tab = Tally[data] _
##gray|(* dictionary: *)## _
dict = Counts[data]|| || || ||
||[[# invert-freq-table]][#invert-freq-table-note frequency table to data set]||f = Function[a, Table[a[[1]], {i, 1, a[[2]]}]] _
data = Flatten[Map[f, tab]]|| || || ||
||[[# bin]][#bin-note bin]||data = {1.1, 3.7, 8.9, 1.2, 1.9, 4.1} _
##gray|(* bins are [0, 3), [3, 6), and [6, 9): *)## _
bins = BinCounts[data, {{0, 3, 6, 9}}]|| || || ||
||||||||||~ [[# distributions]][#distributions-note distributions]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[# binomial]][#binomial-note binomial] _
 _
##gray|//density, cumulative distribution, sample//##||X = BinomialDistribution[100, 1/2] _
 _
PDF[X][50] _
CDF[X][50] _
RandomVariate[X]||from sympy.stats import * _
 _
X = Binomial('X', 100, sympy.Rational(1, 2)) _
 _
density(Y).dict[sympy.Integer(50)] _
P(X < 50) _
sample(X)|| || ||
||[[# poisson]][#poisson-note poisson]||X = PoissonDistribution[1]||##gray|# P(X < 4) raises NotImplementedError:## _
X = Poisson('X', 1)|| || ||
||[[# discrete-uniform]][#discrete-uniform-note discrete uniform]||X = DiscreteUniformDistribution[{0, 99}]||X = DiscreteUniform('X', list(range(0, 100)))|| || ||
||[[# normal]][#normal-note normal] _
 _
##gray|//density, cumulative distribution, quantile, sample//##||X = NormalDistribution[0, 1] _
 _
PDF[X][0] _
CDF[X][0] _
InverseFunction[CDF[X]][1/2] _
RandomVariate[X]||from sympy.stats import * _
 _
X = Normal('X', 0, 1) _
 _
density(X)(0) _
P(X < 0) _
##gray|//??//## _
sample(X)|| || ||
||[[# gamma]][#gamma-note gamma]||X = GammaDistribution[1, 1]||X = Gamma('X', 1, 1)|| || ||
||[[# exponential]][#exponential-note exponential]||X = ExponentialDistribution[1]||X = Exponential('X', 1)|| || ||
||[[# chi-squared]][#chi-squared-note chi-squared]||X = ChiSquareDistribution[2]||X = ChiSquared('X', 2)|| || ||
||[[# beta]][#beta-note beta]||X = BetaDistribution[10, 90]||X = Beta('X', 10, 90)|| || ||
||[[# uniform]][#uniform-note uniform]||X = UniformDistribution[{0, 1}]||X = Uniform('X', 0, 1)|| || ||
||[[# students-t]][#students-t-note student's t]||X = StudentTDistribution[2]||X = StudentT('X', 2)|| || ||
||[[# snedecors-f]][#snedecors-f-note snedecor's F]||X = FRatioDistribution[1, 1]||X = FDistribution('X', 1, 1)|| || ||
||[[# empirical-density-func]][#empirical-density-func-note empirical density function]||X = NormalDistribution[0, 1] _
data = Table[RandomVariate[X], {i, 1, 30}] _
Y = EmpiricalDistribution[data] _
PDF[Y]|| || || ||
||[[# empirical-cumulative-distribution]][#empirical-cumulative-distribution-note empirical cumulative distribution]||X = NormalDistribution[0, 1] _
data = Table[RandomVariate[X], {i, 1, 30}] _
Y = EmpiricalDistribution[data] _
Plot[CDF[Y][x], {x, -4, 4}]|| || || ||
||||||||||~ [[# univariate-charts]][#univariate-chart-note univariate charts]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[image http://farm5.static.flickr.com/4090/5039793334_f76edece33_m.jpg]] [#bar-chart vertical bar chart]||BarChart[{7, 3, 8, 5, 5}, _
@<&nbsp;&nbsp;>@ChartLegends-> _
@<&nbsp;&nbsp;&nbsp;&nbsp;>@{"a","b","c","d","e"}]|| || || ||
||[[image http://farm5.static.flickr.com/4092/5039776078_cc38a4ff5f_m.jpg]] _
[#horizontal-bar-chart horizontal bar chart]||BarChart[{7, 3, 8, 5, 5}, BarOrigin -> Left]|| || || ||
||[[image http://farm5.static.flickr.com/4145/5037819710_d932767cd5_m.jpg]] [#pie-chart pie chart]||PieChart[{7, 3, 8, 5, 5}]|| || || ||
||[[image http://farm5.static.flickr.com/4089/5037399669_13c8e585e0_m.jpg]] _
[#stem-and-leaf-plot stem-and-leaf plot]||Needs["StatisticalPlots@@`@@"] _
nd = NormalDistribution[0, 1] _
n100 = RandomVariate[nd, 100] _
StemLeafPlot[20 * n100]|| || || ||
||[[image http://farm5.static.flickr.com/4106/5037415497_4c6fbfcab2_m.jpg]] [#histogram histogram]||nd = NormalDistribution[0, 1] _
Histogram[RandomReal[nd, 100], 10]|| || || ||
||[[image http://farm5.static.flickr.com/4106/5037525393_7ac86e81c3_m.jpg]] [#box-and-whisker-plot box-and-whisker plot]||nd = NormalDistribution[0, 1] _
n100 = RandomVariate[nd, 100] _
BoxWhiskerChart[d] _
 _
ed = ExponentialDistribution[1] _
e100 = RandomVariate[ed, 100] _
u100 = RandomReal[1, 100] _
d = {n100, e100, u100} _
BoxWhiskerChart[d]|| || || ||
||[#univariate-title set chart title]||BoxWhiskerChart[data, _
@<&nbsp;&nbsp;>@PlotLabel -> "chart example"]|| || || ||
||[#chart-options chart options]||PlotLabel -> "an example" _
 _
AxisLabel -> {"time", "distance"}|| || || ||
||||||||||~ [[# bivariate-charts]][#bivariate-chart-note bivariate charts]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[[image http://farm5.static.flickr.com/4154/5039126187_e340b3f4aa_m.jpg]] _
[#stacked-bar-chart stacked bar chart]||d = @@{{@@7, 1}, {3, 2}, {8, 1}, _
@<&nbsp;&nbsp;>@{5, 3}, {5, 1}} _
BarChart[d, ChartLayout -> _
@<&nbsp;&nbsp;>@"Stacked"]|| || || ||
||[[image http://farm6.static.flickr.com/5044/5267212089_a7749bbe3e_s.jpg]] [#scatterplot scatter plot]||nd = NormalDistribution[0, 1] _
rn = Function[RandomReal[nd]] _
d = {rn[],rn[]} & /@ Range[1,50] _
ListPlot[d]|| || || ||
||[[image http://farm6.static.flickr.com/5089/5267975488_2216ae147e_s.jpg]][#linear-regression-line linear regression line]||d = Table[{i, _
@<&nbsp;&nbsp;>@2 i + RandomReal[{-5, 5}]}, _
@<&nbsp;&nbsp;>@{i, 0, 20}] _
model = LinearModelFit[d, x, x] _
Show[ListPlot[d], _
@<&nbsp;&nbsp;>@Plot[model["BestFit"], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@{x, 0, 20}]]|| || || ||
||[[image http://farm6.static.flickr.com/5125/5267434941_f8537c9d26_s.jpg]] [#polygonal-plot polygonal line plot]||f = Function[i, {i, rn[]}] _
d = f /@ Range[1, 20] _
ListLinePlot[d]|| || || ||
||[[image http://farm6.static.flickr.com/5041/5268071368_75c3aee42e_t.jpg]] [#area-chart area chart]||d = @@{{@@7, 1, 3, 2, 8}, _
@<&nbsp;&nbsp;>@{1, 5, 3, 5, 1}} _
sd = {d[[1]], d[[1]] + d[[2]]} _
ListLinePlot[sd, Filling -> _
@<&nbsp;&nbsp;>@{1 -> {Axis, LightBlue}, _
@<&nbsp;&nbsp;&nbsp;>@2 -> @@{{@@1}, LightRed}}]|| || || ||
||[[image http://farm6.static.flickr.com/5049/5268229340_0b96b5e223_s.jpg]] [#cubic-spline cubic spline]||d = Table[{i, RandomReal[nd]}, _
@<&nbsp;&nbsp;>@{i, 0, 20}] _
f = Interpolation[d, _
@<&nbsp;&nbsp;>@InterpolationOrder -> 3] _
Show[ListPlot[d], _
@<&nbsp;&nbsp;>@Plot[f[x], {x, 0, 20}]]|| || || ||
||[[image http://farm6.static.flickr.com/5204/5268208606_b745646ea6_s.jpg]] [#function-plot function plot]||Plot[Sin[x], {x, -4, 4}]|| || || ||
||[[image http://farm6.static.flickr.com/5048/5267567389_27a19429e4_s.jpg]] [#qq-plot quantile-quantile plot]||nd = NormalDistribution[0, 1] _
d1 = RandomReal[1, 50] _
d2 = RandomReal[nd, 50] _
QuantilePlot[d1, d2]|| || || ||
||[#axis-label axis label]||d = Table[{i, i^2}, {i, 1, 20}] _
ListLinePlot[d, _
@<&nbsp;&nbsp;>@AxesLabel -> {x, x^2}]|| || || ||
||[[# axis-limits]][#axis-limits-note axis limits]||Plot[x^2, {x, 0, 20}, _
@<&nbsp;&nbsp;>@PlotRange -> @@{{0, 20}, {-200, 500}}@@]|| || ||
||[#logarithmic-y-axis logarithmic y-axis]||LogPlot[{x^2, x^3, x^4, x^5}, _
@<&nbsp;&nbsp;>@{x, 0, 20}]|| || || ||
||||||||||~ [[# trivariate-charts]][#trivariate-chart-note trivariate charts]||
||~ ||~ mathematica||~ sympy||~ gap||~ pari/gp||
||[#3d-scatter-plot 3d scatter plot]||nd = NormalDistribution[0,1] _
d = RandomReal[nd, {50, 3}] _
ListPointPlot3D[d]|| || || ||
||[[image http://farm6.static.flickr.com/5245/5268191292_a75a367c39_s.jpg]] [#additional-data additional data set]||nd = NormalDistribution[0, 1] _
x1 = RandomReal[nd, 20] _
x2 = RandomReal[nd, 20] _
ListLinePlot[{x1, x2}]|| || || ||
||[#bubble-chart bubble chart]||nd = NormalDistribution[0,1] _
d = RandomReal[nd, {50, 3}] _
BubbleChart[d]|| || || ||
||[#surface-plot surface plot]||Plot3D[Sinc[Sqrt[x^2 + y^2]], _
@<&nbsp;&nbsp;>@{x, -25, 25}, _
@<&nbsp;&nbsp;>@{y, -25, 25}]|| || || ||
||~ ||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||



[[# version-used-note]]
++ [#version-used version used]

The version of software used to check the examples in the reference sheet.

[[# show-version-note]]
++ [#show-version show version]

How to determine the version of an installation.

[[# implicit-prologue-note]]
++ [#implicit-prologue implicit prologue]

Code assumed to have been executed by the examples in the sheet.

[[# grammar-invocation-note]]
+ [#grammar-invocation Grammar and Invocation]

[[# interpreter-note]]
++ [#interpreter interpreter]

How to execute a script.

**mathematica:**

The full path to MathKernel on Mac OS X:

[[code]]
/Applications/Mathematica.app/Contents/MacOS/MathKernel
[[/code]]

[[# repl-note]]
++ [#repl repl]

How to launch a command line read-eval-print loop for the language.

[[# block-delimiters-note]]
++ [#block-delimiters block delimiters]

How blocks are delimited.

[[# stmt-separator-note]]
++ [#stmt-separator statement separator]

How statements are separated.

[[# eol-comment-note]]
++ [#eol-comment end-of-line comment]

Character used to start a comment that goes to the end of the line.

[[# multiple-line-comment-note]]
++ [#multiple-line-comment multiple line comment]

The syntax for a delimited comment which can span lines.

[[# var-expr-note]]
+ [#var-expr Variables and Expressions]

[[# assignment-note]]
++ [#assignment assignment]

How to perform assignment.

Mathematica, Sympy, and Pari/GP support the chaining of assignments.  For example, in Mathematica one can assign the value 3 to {{x}} and {{y}} with:

[[code]]
x = y = 3
[[/code]]

In Mathematica and Pari/GP, assignments are expressions.  In Mathematica, the following code is legal and evaluates to 7:

[[code]]
(x = 3) + 4
[[/code]]

In Mathematica, the {{Set}} function behaves identically to assignment and can be nested:

[[code]]
Set[a, Set[b, 3]]
[[/code]]

[[# delayed-assignment-note]]
++ [#delayed-assignment delayed assignment]

How to assign an expression to a variable name.  The expression is re-evaluated each time the variable is used.

**mathematica:**

GNU make also supports assignment and delayed assignment, but {{=}} is used for delayed assignment and {{:=}} is used for immediate assignment.  This is the opposite of how Mathematica uses the symbols.

The POSIX standard for make only has {{=}} for delayed assignment.

[[# parallel-assignment-note]]
++ [#parallel-assignment parallel assignment]

How to assign values in parallel.

Parallel assignment can be used to swap the values held in two variables.

[[# compound-assignment-note]]
++ [#compound-assignment compound assignment]

The compound assignment operators.

[[# incr-decr-note]]
++ [#incr-decr increment and decrement]

Increment and decrement operators which can be used in expressions.

[[# non-referential-id-note]]
++ [#non-referential-id non-referential identifier]

An identifier which does not refer to a value.

A non-referential identifier will usually print as a string containing its name.

Expressions containing non-referential identifiers will not be evaluated, though they may be simplified.

Non-referential identifiers represent "unknowns" or "parameters" when performing algebraic derivations.

[[# id-as-val-note]]
++ [#id-as-val identifier as value]

How to get a value referring to an identifier.

The identifier may be the name of a variable containing a value.  But the value referring to the identifier is distinct from the value in the variable.

One may manipulate a value referring to an identifier even if it is not the name of a variable.

[[# global-var-note]]
++ [#global-var global variable]

How to declare a global variable.

[[# local-var-note]]
++ [#local-var local variable]

How to declare a local variable.

**pari/gp:**

There is {{my}} for declaring a local variable with lexical scope and {{local}} for declaring a variable with dynamic scope.

{{local}} can be used to change the value of a global as seen by any functions which are called while the local scope is in effect.

[[# null-note]]
++ [#null null]

The null literal.

[[# null-test-note]]
++ [#null-test null test]

How to test if a value is null.

[[# undef-var-note]]
++ [#undef-var undefined variable access]

What happens when an undefined variable is used in an expression.

[[# rm-var-binding-note]]
++ [#rm-var-binding remove variable binding]

How to remove a variable.  Subsequent references to the variable will be treated as if the variable were undefined.

[[# cond-expr-note]]
++ [#cond-expr conditional expression]

A conditional expression.
[[# arithmetic-logic-note]]
+ [#arithmetic-logic Arithmetic and Logic]

[[# true-false-note]]
++ [#true-false true and false]

The boolean literals.

[[# falsehoods-note]]
++ [#falsehoods falsehoods]

Values which evaluate to false in a conditional test.

**sympy:**

Note that the logical operators {{Not}}, {{And}} and {{Or}} do not treat empty collections or {{None}} as false.  This is different from the Python logical operators {{not}}, {{and}}, and {{or}}.

**pari/gp:**

A vector or matrix evaluates to false if all components evaluate to false.

[[# logical-op-note]]
++ [#logical-op logical operators]

The Boolean operators.

**sympy:**

In Python, {{&}}, {{|}}, and {{&}} are bit operators.  SymPy has defined {{@@__and__@@}}, {{@@__or__@@}}, and {{@@__invert__@@}} methods to make them Boolean operators for symbols, however.

[[# relational-op-note]]
++ [#relational-op relational operators]

The relational operators.

**sympy:**

The full SymPy names for the relational operators are:

[[code]]
sympy.Equality             # ==
sympy.Unequality           # !=
sympy.GreaterThan          # >=
sympy.LessThan             # <=
sympy.StrictGreaterThan    # >
sympy.StrictLessThan       # <
[[/code]]

The SymPy functions are attatched to the relational operators {{==}}, {{!=}}, for symbols ... using the methods {{@@__eq__@@}}, {{@@__ne__@@}}, {{@@__ge__@@}}, {{@@__le__@@}}, {{@@__gt__@@}}, {{@@__lt__@@}}.  The behavior they provide is similar to the default Python behavior, but when one of the arguments is a SymPy expression, a simplification will be attempted before the comparison is made.

[[# arith-op-note]]
++ [#arith-op arithmetic operators]

The arithmetic operators.

[[# int-div-note]]
++ [#int-div integer division]

How to compute the quotient of two integers.

[[# int-div-zero-note]]
++ [#int-div-zero integer division by zero]

The result of dividing an integer by zero.

[[# float-div-note]]
++ [#float-div float division]

How to perform float division, even if the arguments are integers.

[[# float-div-zero-note]]
++ [#float-div-zero float division by zero]

The result of dividing a float by zero.

[[# power-note]]
++ [#power power]

How to compute exponentiation.

Note that zero to a negative power is equivalent to division by zero, and negative numbers to a fractional power may have multiple complex solutions.

[[# sqrt-note]]
++ [#sqrt sqrt]

The square root function.

For positive arguments the positive square root is returned.

[[# sqrt-negative-one-note]]
++ [#sqrt-negative-one sqrt -1]

How the square root function handles negative arguments.

**mathematica:**

An uppercase {{I}} is used to enter the imaginary unit, but Mathematica displays it as a lowercase {{i}}.

[[# transcendental-func-note]]
++ [#transcendental-func transcendental functions]

The standard transcendental functions such as one might find on a scientific calculator.

The functions are the exponential (not to be confused with exponentiation), natural logarithm, sine, cosine, tangent, arcsine, arccosine, arctangent, and the two argument arctangent.

[[# transcendental-const-note]]
++ [#transcendental-const transcendental constants]

The transcendental constants //pi// and //e//.

The transcendental functions can used to computed to compute the transcendental constants:

[[code]]
pi = acos(-1)
pi = 4 * atan(1)
e = exp(1)
[[/code]]

[[# float-truncation-note]]
++ [#float-truncation float truncation]

Ways to convert a float to a nearby integer.

[[# absolute-val-note]]
++ [#absolute-val absolute value]

How to get the absolute value and signum of a number.

[[# int-overflow-note]]
++ [#int-overflow integer overflow]

What happens when the value of an integer expression cannot be stored in an integer.

The languages in this sheet all support arbitrary length integers so the situation does not happen.

[[# float-overflow-note]]
++ [#float-overflow float overflow]

What happens when the value of a floating point expression cannot be stored in a float.

[[# rational-construction-note]]
++ [#rational-construction rational construction]

How to construct a rational number.

[[# rational-decomposition-note]]
++ [#rational-decomposition rational decomposition]

How to extract the numerator and denominator from a rational number.

[[# decimal-approx-note]]
++ [#decimal-approx decimal approximation]

How to get a decimal approximation of an irrational number or repeating decimal rational.

[[# complex-construction-note]]
++ [#complex-construction complex construction]

How to construct a complex number.

[[# complex-decomposition-note]]
++ [#complex-decomposition complex decomposition]

How to extract the real and imaginary part from a complex number; how to extract the argument and modulus; how to get the complex conjugate.

[[# random-num-note]]
++ [#random-num random number]

How to generate a random integer or a random float.

**pari/gp:**

When the argument of {{random()}} is an integer {{n}}, it generates an integer in the range [[$ \{0, ..., n - 1\} $]].

When the argument is a arbitrary precision float, it generates a value in the range {{[0.0, 1.0]}}.  The precision of the argument determines the precision of the random number.

[[# random-seed-note]]
++ [#random-seed random seed]

How to set or get the random seed.

**mathematica:**

The seed is not set to the same value at start up.

[[# bit-op-note]]
++ [#bit-op bit operators]


[[# binary-octal-hex-literals-note]]
++ [#binary-octal-hex-literals binary, octal, and hex literals]

Binary, octal, and hex integer literals.

**mathematica:**

The notation works for any base from 2 to 36.

[[# radix-note]]
++ [#radix radix]

Convert a number to a representation using a given radix.

[[# to-array-of-digits-note]]
++ [#to-array-of-digits to array of digits]

Convert a number to an array of digits representing the number.

[[# strings-note]]
+ [#strings Strings]

[[# str-literal-note]]
++ [#str-literal string literal]

The syntax for a string literal.

[[# newline-in-str-literal-note]]
++ [#newline-in-str-literal newline in literal]

Are newlines permitted in string literals.

[[# str-literal-esc-note]]
++ [#str-literal-esc literal escapes]

Escape sequences for putting unusual characters in string literals.

[[# str-concat-note]]
++ [#str-concat concatenate]

How to concatenate strings.

[[# translate-case-note]]
++ [#translate-case translate case]

How to convert a string to all lower case letters or all upper case letters.

[[# trim-note]]
++ [#trim trim]

How to remove whitespace from the beginning or the end of string.

[[# num-to-str-note]]
++ [#num-to-str number to string]

How to convert a number to a string.

[[# str-to-num-note]]
++ [#str-to-num string to number]

How to parse a number from a string.

[[# str-join-note]]
++ [#str-join string join]

How to join an array of strings into a single string, possibly separated by a delimiter.

[[# split-note]]
++ [#split split]

How to split a string in to an array of strings.  How to specify the delimiter.

[[# str-subst-note]]
++ [#str-subst substitute]

How to substitute one or all occurrences of substring with another.

[[# str-len-note]]
++ [#str-len length]

How to get the length of a string in characters.

[[# index-substr-note]]
++ [#index-substr index of substring]

How to get the index of the first occurrence of a substring.

[[# extract-substr-note]]
++ [#extract-substr extract substring]

How to get a substring from a string using character indices.

[[# char-literal-note]]
++ [#char-literal character literal]

The syntax for a character literal.

[[# lookup-char-note]]
++ [#lookup-char character lookup]

How to get a character from a string by index.

[[# chr-ord-note]]
++ [#chr-ord chr and ord]

Convert a character code point to a character or a single character string.

Get the character code point for a character or single character string.

[[# delete-char-note]]
++ [#delete-char delete characters]

Delete all occurrences of a set of characters from a string.

[[# resizable-arrays-note]]
+ [#resizable-arrays Resizable Arrays]

[[# array-literal-note]]
++ [#array-literal literal]

The notation for an array literal.

[[# array-size-note]]
++ [#array-size size]

The number of elements in the array.

[[# array-lookup-note]]
++ [#array-lookup lookup]

How to access an array element by its index.

[[# array-update-note]]
++ [#array-update update]

How to change the value stored at an array index.

[[# array-out-of-bounds-note]]
++ [#array-out-of-bounds out-of-bounds behavior]

What happens when an attempt is made to access an element at an out-of-bounds index.

[[# array-element-index-note]]
++ [#array-element-index element index]

How to get the index of an element in an array.

[[# array-slice-note]]
++ [#array-slice slice]

How to extract a subset of the elements.  The indices for the elements must be contiguous.

[[# array-of-integers-as-index-note]]
++ [#array-of-integers-as-index array of integers as index]

[[# array-back-note]]
++ [#array-back manipulate back]

[[# array-front-note]]
++ [#array-front manipulate front]

[[# array-head-note]]
++ [#array-head head]

[[# array-tail-note]]
++ [#array-tail tail]

[[# array-cons-note]]
++ [#array-cons cons]

[[# array-concatenate-note]]
++ [#array-concatenate concatenate]

[[# array-replicate-note]]
++ [#array-replicate replicate]

[[# copy-array-note]]
++ [#copy-array copy]

How to copy an array.  Updating the copy will not alter the original.

[[# iterate-over-array-note]]
++ [#iterate-over-array iterate]

[[# reverse-array-note]]
++ [#reverse-array reverse]

[[# sort-array-note]]
++ [#sort-array sort]

[[# dedupe-array-note]]
++ [#dedupe-array dedupe]

[[# membership-note]]
++ [#membership membership]

How to test whether a value is an element of a list.

[[# intersection-note]]
++ [#intersection intersection]

How to to find the intersection of two lists.

[[# union-note]]
++ [#union union]

How to find the union of two lists.

[[# set-diff-note]]
++ [#set-diff relative complement, symmetric difference]

How to find all elements in one list which are not in another; how to find all elements which are in one of two lists but not both.

[[# map-note]]
++ [#map map]

[[# filter-note]]
++ [#filter filter]

[[# reduce-note]]
++ [#reduce reduce]

[[# universal-existential-test-note]]
++ [#universal-existential-test universal and existential tests]

[[# min-max-elem-note]]
++ [#min-max-elem min and max element]

[[# shuffle-sample-note]]
++ [#shuffle-sample shuffle and sample]

How to shuffle an array. How to extract a random sample from an array without replacement.

[[# flatten-note]]
++ [#flatten flatten]

[[# zip-note]]
++ [#zip zip]

How to interleave two arrays.

[[# cartesian-product-note]]
++ [#cartesian-product cartesian product]

[[# arith-seq-note]]
+ [#arith-seq Arithmetic Sequences]

[[# dictionaries-note]]
+ [#dictionaries Dictionaries]

[[# record-literal]]
++ record literal


[[# record-access]]
++ record member access

[[# functions-note]]
+ [#functions Functions]

[[# definition]]
++ definition

[[# invocation]]
++ invocation

[[# function-value]]
++ function value

[[# execution-control-note]]
+ [#execution-control Execution Control]

[[# if]]
++ if

How to write a branch statement.

**mathematica:**

The 3rd argument (the else clause) of an //If// expression is optional.

[[# while]]
++ while

How to write a conditional loop.

**mathematica:**

//Do// can be used for a finite unconditional loop:

[[code]]
Do[Print[foo], {10}]
[[/code]]

[[# for]]
++ for

How to write a C-style for statement.

[[# break-continue]]
++ break/continue

How to break out of a loop.  How to jump to the next iteration of a loop.

[[# exceptions-note]]
+ [#exceptions Exceptions]

[[# raise-exc-note]]
++ [#raise-exc raise exception]

How to raise an exception.

[[# handle-exc-note]]
++ [#handle-exc handle exception]

How to handle an exception.

[[# uncaught-exc-note]]
++ [#uncaught-exc uncaught exception behavior]

**gap:**

Calling {{Error()}} invokes the GAP debugger, which is similar to a Lisp debugger.  In particular, all the commands available in the GAP REPL are still available.  Variables can be inspected and modified while in the debugger but any changes will be lost when the debugger is quitted.

One uses {{quit;}} or {{^D}} to exit the debugger.  These commands also cause the top-level GAP REPL exit if used while not in a debugger.

If {{Error()}} is invoked while in the GAP debugger, the  debugger will be invoked recursively.   One must use {{quit;}} for each level of debugger recursion to return to the top -level GAP REPL.

Use

[[code]]
brk> Where(4);
[[/code]]

to print the top four functions on the stack when the error occurred.  Use {{DownEnv()}} and {{UpEnv()}} to move down the stack—i.e. from callee to caller—and {{UpEnv()}} to move up the stack.  The commands take the number of levels to move down or up:

[[code]]
brk> DownEnv(2);
brk> UpEnv(2);
[[/code]]

When the debugger is invoked, it will print a message.  It may give the user the option of providing a value with the {{return}} statement so that a computation can be continued:

[[code]]
brk> return 17;
[[/code]]

[[# finally]]
++ finally block

How to write code that executes even if an exception is raised.

[[# streams-note]]
+ [#streams Streams]

[[# files-note]]
+ [#files Files]

[[# directories-note]]
+ [#directories Directories]

[[# libraries-namespaces-note]]
+ [#libraries-namespaces Libraries and Namespaces]

[[# reflection-note]]
+ [#reflection Reflection]

[[# function-documentation]]
++ function documentation

How to get the documentation for a function.

[[# vectors-note]]
+ [#vectors Vectors]

[[# vec-literal-note]]
++ [#vec-literal vector literal]

The notation for a vector literal.

[[# const-vec-note]]
++ [#const-vec constant vector]

How to create a vector with components all the same.

[[# vec-coordinate-note]]
++ [#vec-coordinate vector coordinate]

How to get one of the coordinates of a vector.

[[# vec-dim-note]]
++ [#vec-dim vector dimension]

How to get the number of coordinates of a vector.

[[# vec-element-wise-note]]
++ [#vec-element-wise element-wise arithmetic operators]

How to perform an element-wise arithmetic operation on vectors.

[[# vec-length-mismatch-note]]
++ [#vec-length-mismatch vector length mismatch]

What happens when an element-wise arithmetic operation is performed on vectors of different dimension.

[[# vec-scalar-note]]
++ [#vec-scalar scalar multiplication]

How to multiply a scalar with a vector.

[[# vec-dot-note]]
++ [#vec-dot dot product]

How to compute the dot product of two vectors.

[[# vec-cross-note]]
++ [#vec-cross cross product]

How to compute the cross product of two three-dimensional vectors.

[[# vec-norms-note]]
++ [#vec-norms norms]

How to compute the norm of a vector.


[[# matrices-note]]
+ [#matrices Matrices]

[[# matrix-literal-constructor]]
++ literal or constructor

Literal syntax or constructor for creating a matrix.

**mathematica:**

Matrices are represented as lists of lists.  No error is generated if one of the rows contains too many or two few elements.  The //MatrixQ// predicate can be used to test whether a list of lists is matrix: i.e. all of the sublists contain numbers and are of the same length.

Matrices are displayed by Mathematica using list notation.  To see a matrix as it would be displayed in mathematical notation, use the //MatrixForm// function.

[[# matrix-dimensions]]
++ dimensions

How to get the dimensions of a matrix.

[[# matrix-access]]
++ element access

How to access an element of a matrix.  All languages described here follow the convention from mathematics of specifying the row index before the column index.

[[# matrix-row-access]]
++ row access

How to access a row.

[[# matrix-column-access]]
++ column access

How to access a column.

[[# submatrix-access]]
++ submatrix access

How to access a submatrix.

[[# matrix-scalar-multiplication]]
++ scalar multiplication

How to multiply a matrix by a scalar.

[[# matrix-element-wise-operators]]
++ element-wise operators

Operators which act on two identically sized matrices element by element.  Note that element-wise multiplication of two matrices is used less frequently in mathematics than matrix multiplication.

[[# matrix-multiplication]]
++ multiplication

How to multiply matrices.  Matrix multiplication should not be confused with element-wise multiplication of matrices.  Matrix multiplication in non-commutative and only requires that the number of columns of the matrix on the left match the number of rows of the matrix.  Element-wise multiplication, by contrast, is commutative and requires that the dimensions of the two matrices be equal.

[[# kronecker-product]]
++ kronecker product

The [http://en.wikipedia.org/wiki/Kronecker_product Kronecker product] is a non-commutative operation defined on any two matrices.  If A is m x n and B is p x q, then the Kronecker product is a matrix with dimensions mp x nq.

[[# matrix-comparison]]
++ comparison

How to test two matrices for equality.

[[# matrix-norms]]
++ norms

How to compute the 1-norm, the 2-norm, the infinity norm, and the frobenius norm.

[[# symbolic-expr-note]]
+ [#symbolic-expr Symbolic Expressions]

[[# calculus-note]]
+ [#calculus Calculus]

[[# equations-unknowns-note]]
+ [#eqn Equations and Unknowns]

[[# optimization-note]]
+ [#optimization Optimization]

An optimization problem consists of a real-valued function called the //objective function//.

The objective function takes one or more //input variables//.  In the case of a maximization problem, the goal is to find the value for the input variables where the objective function achieves its maximum value.  Similarly for a minimization function one looks for the values for which the objective function achieves its minimum value.

[[# minimize-note]]
++ [#minimize minimize]

How to solve a minimization problem in one variable.

[[# maximize-note]]
++ [#maximize maximize]

How to solve a maximization problem.

We can use a function which solves minimization problems to solve maximization problems by negating the objective function.  The downside is we might forget the minimum value returned is the negation of the maximum value we seek.

[[# optimize-unknown-param-note]]
++ [#optimize-unknown-param objective with unknown parameter]

How to solve an optimization when the objective function contains unknown parameters.

[[# unbounded-behavior-note]]
++ [#unbounded-behavior unbounded behavior]

What happens when attempting to solve an unbounded optimization problem.

[[# optimize-multiple-var-note]]
++ [#optimize-multiple-var multiple variables]

How to solve an optimization problem with more than one input variable.

[[# optimize-constraints-note]]
++ [#optimize-constraints constraints]

How to solve an optimization with constraints on the input variable.  The constrains are represented by inequalities.

[[# infeasible-behavior-note]]
++ [#infeasible-behavior infeasible behavior]

What happens when attempting to solve an optimization problem when the solution set for the constraints is empty.

[[# optimize-int-var-note]]
++ [#optimize-int-var integer variables]

How to solve an optimization problem when the input variables are constrained to linear values.

[[# numerical-opt-note]]
++ [#numerical-opt numerical optimization]

Alternatives for finding optima which use numerical methods instead of exact methods.

The techniques use heuristics for finding global optima which may not work in some cases.

[[# local-opt-near-point-note]]
++ [#local-opt-near-point local optimum near point]

Numerical methods for finding a local optima near a specified point.

[[# combinatorics-note]]
+ [#combinatorics Combinatorics]

[[# number-theory-note]]
+ [#number-theory Number Theory]

[[# pseudoprime-test-note]]
++ [#pseudoprime-test pseudoprime test]

A fast primality test.

A number of primality tests exists which give occasional false positives.  The simplest of these use Fermat's Little Theorem, in which for prime //p// and //a// in [[$ \{1, ..., p - 1\} $]]:

[[math]]
a^{p-1} \equiv 1 \;(\text{mod}\; p)
[[/math]]

The test for a candidate prime //p// is to randomly choose several values for //a// in  [[$ \{1, ..., p - 1\} $]] and evaluate

[[math]]
a^{p-1} \;(\text{mod}\; p)
[[/math]]

If any of them are not equivalent to 1, then the test shows that p is not prime.  Unfortunately, there are composite numbers //n//, the [https://oeis.org/A002997 Carmichael numbers], for which

[[math]]
a^{n-1} \equiv 1 \;(\text{mod}\; n)
[[/math]]

holds for all //a// in [[$ \{1, ..., n - 1\} $]].

A stronger test is the Miller-Rabin primality test.  Given a candidate prime //n//, we factor //n - 1// as 2^^r^^ ⋅ //d// where //d// is odd.  If //n// is prime, then one of the following must be true:

[[math]]
a^d \equiv 1 \;(\text{mod}\;n)
[[/math]]

[[math]]
a^{2^r \cdot d} \equiv -1 \;(\text{mod}\;n)
[[/math]]


[[# true-prime-test-note]]
++ [#true-prime-test true prime test]

Pseuodoprime tests are known for which there are no known counterexamples, and which are correct for all integers up to a very large size.  Since conclusively showing that a number is prime is a slow operation for larger integers, a true prime test is often not practical.

[[# divisors-note]]
++ [#divisors divisors]

The list of divisors for an integer.

[[# prime-factors-note]]
++ [#prime-factors prime factors]

The list of prime factors for an integer, with their multiplicities.

[[# next-prime-note]]
++ [#next-prime next prime]

The smallest prime number greater than an integer.  Also the greatest prime number smaller than an integer.

[[# nth-prime-note]]
++ [#nth-prime nth prime]

The n-th prime number.

[[# prime-counting-func-note]]
++ [#prime-counting-func prime counting function]

The number of primes less than or equal to a value.

According to the prime number theorem:

[[math]]
\lim_{n \rightarrow \infty} \frac{\pi(n)}{n/\log n} = 1
[[/math]]

[[# divmod-note]]
++ [#divmod divmod]

The quotient and remainder.

If the divisor is positive, then the remainder is non-negative.

[[# gcd-note]]
++ [#gcd greatest common divisor]

The greatest common divisor of a pair of integers.  The divisor is always positive.

Two integers are relatively prime if their greatest common divisor is one.

[[# extended-euclidean-algorithm-note]]
++ [#extended-euclidean-algorithm extended euclidean algorithm]

How to express a greatest common divisor as a linear combination of the integers it is a GCD of.

The functions described return the GCD in addition to the coefficients.

[[# lcm-note]]
++ [#lcm least common multiple]

The least common multiple of a pair of integers.

The LCM can be calculated from the GCD using this formula:

[[math]]
\text{lcm}(m, n) = \frac{|m\cdot n|}{\text{gcd}(m, n)}
[[/math]]

[[# int-residues-note]]
++ [#int-residues integer residues]

The integer residues or integers modulo //n// are the equivalence classes formed by the relation

[[math]]
a\;(\text{mod}\;n) = b\; (\text{mod}\;n)
[[/math]]

An element in of these equivalence classes is called a representative.  We can extend addition and multiplication to the residues by performing integer addition or multiplication on representatives.  This is well-defined in the sense that it does not depend on the representatives chosen.  Addition and multiplication defined this way turn the integer residues into commutative rings with identity.

[[# mult-inverse-note]]
++ [#mult-inverse multiplicative inverse]

How to get the multiplicative inverse for a residue.

If the representative for a residue is relatively prime to the modulus, then the residue has a multiplicative inverse.  For that matter, if the modulus //n// is a prime, then the ring of residues is a field.

Note that we cannot in general find the inverse using a representative, since the only units in the integers are -1 and 1.

By Euler's theorem, we can find a multiplicative inverse by raising it to the power [[$ \phi(n) - 1 $]]:

[[math]]
a^{\phi(n) - 1} \cdot a = a^{\phi(n)} \equiv 1 \;(\text{mod}\;n)
[[/math]]

When //a// doesn't have a multiplicative inverse, then we cannot cancel it from both sides of a congruence.  The following is true, however:

[[math]]
az \equiv az' \;(\text{mod}\; n) \iff z \equiv z' \;\left(\text{mod}\; \frac{n}{\text{gcd}(a, n)}\right)
[[/math]]

[[# chinese-remainder-thm-note]]
++ [#chinese-remainder-thm chinese remainder theorem]

A function which finds a solution to a system of congruences.

The Chinese remainder theorem asserts that there is a solution //x// to the system of  //k//  congruences

[[math]]
x \equiv a_i \;(\text{mod}\;n_i)
[[/math]]

provided that the //n,,i,,// are pairwise relatively prime.  In this case there are an infinite number of solutions, all which are equal modulo [[$ N = n_1 \cdots n_k $]].  For this reason the solution is returned as a residue modulo //N//.

[[# lift-int-residue-note]]
++ [#lift-int-residue lift integer residue]

How to get a representative from the equivalence class of integers modulo //n//.

Typically an integer in [[$ \{0, ..., n - 1\} $]] is chosen.  A centered lift chooses a representative //x// such that [[$ -n/2 < x \leq n/2 $]].

[[# euler-totient-note]]
++ [#euler-totient euler totient]

The Euler totient function is defined for any positive integer //n// as:

[[math]]
\phi(n) = n \prod_{p | n} \frac{p - 1}{p}
[[/math]]

Note that the product is over the primes that divide //n//.

The Euler totient is the number of integers in [[$ \{1, ..., n - 1\} $]] which are relatively prime to //n//.  It is thus the size of the multiplicative group of integers modulo //n//.

The Euler totient appears in Euler's theorem:

[[math]]
a^{\phi(n)} \equiv 1 \;(\text{mod}\;n)
[[/math]]

[[# mult-order-note]]
++ [#mult-order multiplicative order]

The multiplicative order of a residue //a// is the smallest exponent //k// such that

[[math]]
a^k \equiv 1\;(\text{mod}\;n)
[[/math]]

In older literature, it is sometimes said that //a// belongs to the exponent //k// modulo //n//.

[[# primitive-roots-note]]
++ [#primitive-roots primitive roots]

A primitive root is a residue module //n// with multiplicative order //φ(n)//.

The multiplicative group is not necessarily cyclic, though it is when //n// is prime.  If it is not cyclic, then there are no primitive roots.

Any primitive root is a generator for the multiplicative group, so it can be used to find the other primitive roots.

[[# discrete-log-note]]
++ [#discrete-log discrete logarithm]

For a residue //x// and a base residue //b//, find a positive integer such that:

[[math]]
b^k \equiv x\;(\text{mod}\; n)
[[/math]]

[[# carmichael-func-note]]
++ [#carmichael-func carmichael function]

The smallest number //k// such that //a^^k^^ ≡ 1 (//mod //n)// for all residues //a//.

The Carmichael function λ(n) is less that or equal to the Euler totient function φ(n).  The functions are equal when there are primitive roots modulo //n//.

[[# kronecker-symbol-note]]
++ [#kronecker-symbol kronecker symbol]

A quadratic residue is a non-zero residue //a// which has a square root modulo //p//.  That is, there is //x// such that

[[math]]
x^2 \equiv a \;(\text{mod}\;p)
[[/math]]

If //a// is non-zero and doesn't have a square root, then it is a quadratic non-residue.

The Legendre symbol is used to indicate whether a number is a quadratic residue and is defined as follows:

[[math]]
\left( \frac{a}{p} \right)  = \begin{cases} \;\; 1 \;\;\; a \; \text{is a quadratic residue} \\ \;\; 0 \;\;\; p \mid a \\ -1 \;\;\; a \; \text{is a quadratic nonresidue} \end{cases}
[[/math]]

The Legendre symbol is only defined when //p// is prime, but if //n// is a positive integer with prime factorization

[[math]]
p_1^{\alpha_1} \ldots p_n^{\alpha_n}
[[/math]]

then the Jacobi symbol is defined as

[[math]]
\left( \frac{a}{n} \right) = \left( \frac{a}{p_1} \right)^{\alpha_1} \ldots \left( \frac{a}{p_n} \right)^{\alpha_n}
[[/math]]

[[# moebius-func-note]]
++ [#moebius-func moebius function]

The Möbius function //μ(n)// is 1, -1, or 0 depending upon when //n// is a square-free integer with an even number of prime factors, a square-free integer with an odd number of prime factors, or an integer which is divisible by //p^^2^^// for some prime //p//.

The Möbius function is multiplicative: when //a// and //b// are relatively prime, //μ(a)μ(b) = μ(ab)//.

//Möbius inversion formula//

[[# riemann-zeta-func-note]]
++ [#riemann-zeta-func riemann zeta function]

[[# dirichelt-char-note]]
++ [#dirichlet-char dirichlet character]

[[# mangoldt-lambda-note]]
++ [#mangoldt-lambda mangoldt lambda]

[[# elliptic-curves-note]]
+ [#elliptic-curves Elliptic Curves]

The //multidegree// of a multivariate monomial is the sum of the exponents of the indeterminates.  E.g. the multidegree of {{x²y⁵z³}} is 10.

The //multidegree// of a multivariate polynomial is the maximum of the multidegrees of its terms.

A //cubic multivariate polynomial// is a multivariate polynomial of multidegree 3.

An elliptic curve can be represented by a cubic bivariate polynomial.

Geometrically, the zeros of a cubic bivariate polynomial form a curve in the coordinate plane.  It is customary, however, to study elliptic curves in the projective plane.  To get the projective plane, we take the set of triples (a, b, c), not all zero, and we define an equivalence relation on them where (a, b, c) = (ta, tb, tc) for any non-zero t.  If c is non-zero, the (a/c, b/c, 1) is an element of this class, and by associating x with a/c and y with b/c this gives us a way of embedding the coordinate plane in the projective plane.  Points in the projective plane with c = 0 can be thought of as points at infinity. 

Two curves are //birationally equivalent// if there exist coordinate transformations going both directions which are rational functions and which map one curve to the other.

Every cubic bivariate polynomial is birationally equivalent to a polynomial in //Weierstrass normal form//:

[[math]]
y^2 = x^3 + a x + b
[[/math]]

A consequence of Bezout's theorem is that any line will intersect a cubic bivariate polynomial in three places.  The field of coefficients must be ℂ, and the coordinates must be projective to account for intersection at infinity.  Also, one must allow for multiple intersections at a point.

The //discriminant// of an elliptic curve in Weierstrass normal form is:

[[math]]
-16(4a^3 + 27b^2)
[[/math]]

An elliptic curve is said to be singular if the discriminant is non-zero.  Geometrically, non-singular curves do not intersect themselves and don't have any cusps or isolated points.

A line will intersect a non-singular elliptic curve at three points in projective space.  One can thus use the elliptic curve to define an abelian group in the following manner.  Given points P and Q, define {{P * Q}} as the third point of intersection on the curve of the line defined by P and Q.  Define {{P + Q}} as the third point of intersection of the line defined by {{P * Q}} and the point {{O}} at infinity.  Note that {{+}} and not {{*}} is the group operator.  To add a point P to itself, we use the tangent line of the elliptic curve at P.  We define {{P * P}} as the third point of intersection of the tangent line with the curve, and {{P + P}} as the third point of intersection of the line defined by {{P * P}} and the point at infinity {{O}}.

[[# rational-algebraic-numbers-note]]
+ [#rational-algebraic-numbers Rational and Algebraic Numbers]

[[# polynomials-note]]
+ [#polynomials Polynomials]

[[# trigonometry-note]]
+ [#trigonometry Trigonometry]

[[# special-functions-note]]
+ [#special-functions Special Functions]

[[# permutations-note]]
+ [#permutations Permutations]

A permutation is a bijection on a set of //n// elements.

The notation that Mathematica and GAP use assumes the set the permutation operates on is indexed by {1, .., n}.  The notation that SymPy uses assumes the set is indexed by {0, ..., n-1}.

//Cayley two line notation//

//one line notation//

//cycle notation//

//inversions//

[[# groups-note]]
+ [#groups Groups]

A //group// is a set G and a binary operator—written here as{{*}}—which takes elements of the set as operands and obeys the following axioms:

* //Closure:// For every g and h in G, g * h is also in G.
* //Identity:// There exists e in G such that for all g in G, e * g = g * e = g.
* //Associativity:// For all f, g and h in G, (f * g) * h = f * (g * h).
* //Inverse:// For every g in G, there exists g' in G such that g * g' = g' * g = e.

//Abelian// groups obey an additional axiom:

* //Commutativity:// For all g and h in G, g * h = h * g.

The //order// of a group is the number elements in the set.  The smallest group is the //trivial group//, which contains a single element which is the identity.  It has order 1.

The integers, rationals, real numbers, and complex numbers are Abelian groups under addition; zero is the identity element.  The integers and rationals are countably infinite.  The real numbers and complex numbers are uncountably infinite.

The integers modulo //n// are an Abelian group under addition; zero is the identity number.  The group is finite and has order //n//.

The non-zero rationals, non-zero real numbers, and non-zero complex numbers are Abelian groups under multiplication; one is the identity element.

The set of permutations on a set of //n// elements are non-Abelian groups under composition; the identity permutation which maps each element of the set to itself is the identiy.  The order of the group is //n//!.

++ classical lie groups

The classical Lie groups provide examples of infinite, non-Abelian groups.  In all cases the group operation is matrix multiplication:

||GL(n, ℝ)||general linear group of degree n||invertible n×n matrices||
||SL(n, ℝ)||special linear group of degree n||n×n matrices with determinant one||
||O(n, ℝ)||orthogonal group of degree n||n×n orthogonal matrices; i.e. MM^^T^^ = I||
||SO(n, ℝ)||special orthogonal group of degree n||n×n orthogonal matrices with determinant one||
||U(n, ℂ)||unitary group of degree n||n×n unitary matrices; i.e. MM* = I||
||SU(n, ℂ)||special unitary group of degree n||n×n unitary matrices with determinant one||

++ group from generators

**gap:**

When a group is created using {{GroupByGenerators}}, the generators returned by {{GeneratorsOfGroup}} will not necessarily be the same as the generators provided to the constructor.

If the group is created using {{GroupWithGenerators}}, then the generators returned by {{GeneratorsOfGroup}} will be the same.

++ named groups

[[# subgroups-note]]
+ [#subgroups Subroups]

A //subgroup// is a subset of a group which is itself a group.

//testing whether a set is a subgroup//

A nontrivial group always has at least two subgroups: the group itself and the trivial subgroup.

++ subgroup from generators

**gap:**

{{ClosureGroup}} finds the smallest group containing a group and a list of elements, some of which might not be in the group which is the first argument.


[[# group-homomorphisms-note]]
+ [#group-homomorphisms Group Homomorphisms]

A //homomorphism// is a function φ from (G, *) to (H, *') such that

* φ(x * y) = φ(x) *' φ(y) for all x, y ∈ G.

An //isomorphism// is a bijective //homomorphism//.

If an isomorphism exists between two groups, they are said to be //isomorphic//.   Isomorphic groups are in a sense the same, except that the elements and the operation are written differently.  Isomorphism is an equivalence relation.  Group theory is the study of properties which if they hold for one member of an isomorphism equivalence class, they hold for all members of the equivalence class.

[[# actions-note]]
+ [#actions Actions]

A group G is said to //act// on a set A if there is an operation ⋅: G × A → A such that

* g₁⋅(g₂⋅a) = (g₁*g₂)⋅a for all g₁, g₂ ∈ G and a ∈ A
* e⋅a = a for all a ∈ A where e is the identity in A

[[# descriptive-statistics-note]]
+ [#descriptive-statistics Descriptive Statistics]

[[# distributions-note]]
+ [#distributions Distributions]

[[# univariate-chart-note]]
+ [#univariate-charts Univariate Charts]

A univariate chart can be used to display a list or array of numerical values.  Univariate data can be displayed in a table with a single column or two columns if each numerical value is given a name.  A multivariate chart, by contrast, is used to display a list or array of //tuples// of numerical values.

In order for a list of numerical values to be meaningfully displayed in a univariate chart, it must be meaningful to perform comparisons (<, >, =) on the values.  Hence the values should have the same unit of measurement.

[[# bar-chart]]
++ vertical bar chart

A chart which represents values with rectangular bars which line up on the bottom.  It is a deceptive practice for the bottom not to represent zero, even if a y-axis with labelled tick marks or grid lines is provided.  A cut in the vertical axis and one of the bars may be desirable if the cut value is a large outlier.  Putting such a cut all of the bars near the bottom is a deceptive practice similar not taking to the base of the bars to be zero, however.

Another bad practice is the 3D bar chart.  In such a chart heights are represented by the height of what appear to be three dimensional blocks.  Such charts impress an undiscriminating audience but make it more difficult to make a visual comparison of the charted quantities.

**mathematica**

[[# horizontal-bar-chart]]
++ horizontal bar chart

A bar chart in which zero is the y-axis and the bars extend to the right.

[[# pie-chart]]
++ pie chart

A bar chart displays values using the areas of circular sectors or equivalently, the lengths of the arcs of those sectors.  A pie chart implies that the values are percentages of a whole.  The viewer is likely to make an assumption about what the whole circle represents.  Thus, using a pie chart to show the revenue of some companies in a line of business could be regarded as deceptive if there are other companies in the same line of business which are left out.  The viewer may mistakenly assume the whole circle represents the total market.

If two values are close in value, people cannot determine visually which of the corresponding sectors in a pie chart is larger without the aid of a protractor.  For this reason many consider bar charts superior to pie charts.

Many software packages make 3D versions of pie charts which communicate no additional information and in fact make it harder to interpret the data.

[[# stem-and-leaf-plot]]
++ stem-and-leaf plot

[[# histogram]]
++ histogram

[[# box-and-whisker-plot]]
++ box-and-whisker plot

[[# univariate-title]]
++ set chart title

[[# bivariate-chart-note]]
+ [#bivariate-charts Bivariate Charts]

[[# stacked-bar-chart]]
++ stacked bar chart

[[# trivariate-chart-note]]
+ [#trivariate-charts Trivariate Charts]

[[# mathematica]]
+ [#top Mathematica]

[http://reference.wolfram.com/mathematica/guide/Mathematica.html Mathematica Documentation Center]
[http://wolframalpha.com WolframAlpha]

[[# sympy]]
+ [#top SymPy]

[http://docs.sympy.org/latest/index.html Welcome to SymPy’s documentation!]

[[# gap]]
+ [#top GAP]

[http://www.gap-system.org/Manuals/doc/ref/chap0.html GAP - Reference Manual]

[[# pari-gp]]
+ [#top Pari/GP]

[http://pari.math.u-bordeaux.fr/pub/pari/manuals/2.5.0/tutorial.pdf A Tutorial for Pari/GP (pdf)]
[http://pari.math.u-bordeaux.fr/dochtml/html.stable/ Pari/GP Functions by Category]
[http://www.staff.science.uu.nl/~beuke106/boek/refcard.pdf Pari/GP Reference Card (pdf)]